{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-04-20T02:05:15.159998+00:00",
  "repo": "ietf-wg-mimi/draft-ietf-mimi-content",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "WG reviewed",
      "description": "Issue has been reviewed in a MIMI WG meeting",
      "color": "fef2c0"
    },
    {
      "name": "ready-for-PR",
      "description": "",
      "color": "386457"
    },
    {
      "name": "needs consensus",
      "description": "questions that need to go to the MIMI list",
      "color": "2D0F66"
    },
    {
      "name": "policyknob",
      "description": "",
      "color": "6E68ED"
    },
    {
      "name": "has-PR",
      "description": "",
      "color": "DC800E"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJiBc4M5p1Zwv",
      "title": "Examples missing body.disposition = render",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/1",
      "state": "CLOSED",
      "author": "coopdanger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Some of the examples are missing body.disposition = render, including 5.1, 5.2, 5.5.",
      "createdAt": "2023-06-26T21:00:26Z",
      "updatedAt": "2023-07-18T04:09:36Z",
      "closedAt": "2023-07-18T04:09:36Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in [this commit](https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/commit/277d2ad19185b0ea3359f68e35e72d765f94c895)\r\n\r\nThanks,\r\n-rohan",
          "createdAt": "2023-07-18T04:09:36Z",
          "updatedAt": "2023-07-18T04:09:36Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOJiBc4M5q5yVO",
      "title": "Ordering of messages in thread by client-controlled timestamp field",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/4",
      "state": "CLOSED",
      "author": "anoadragon453",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> Every MIMI content message has a timestamp {2} when the message was encrypted. It is represented as the whole number of milliseconds since the start of the UNIX epoch (01-Jan-1970 00:00:00 UTC).\r\n\r\n> The sort order for messages within a thread uses the timestamp field. If more than one message has the same timestamp, the lexically lowest message ID sorts earlier.\r\n\r\nIn a thread, the ordering of messages looks to only be determined by the `timestamp` field (other than when carrying out a tie-break). `timestamp` is a field controlled by the client that encrypts the message, and is hidden from the server. This implies that if another client receives a message that appears to be in the past, they have no method to prove otherwise. This can help enable social engineering attacks like the one below:\r\n\r\n**Group chat**\r\n```\r\n1| Eve: Alice, are users allowed to post images in this room? <-- deleted later on\r\n2| Eve: Alice, may I have access to the deploy scripts for the website? <-- inserted later on\r\n3| Alice: Yes, that's fine Eve.\r\n```\r\n\r\n**Alice<->Bob DM**\r\n```\r\n1| Eve: Bob, Alice OK'd giving me permissions in room N. [link](link-to-group-dm)\r\n2| Bob: Ack, adding you.\r\n```\r\n\r\nIs this specific to threads, or does ordering of messages in the room generally also only rely on the `timestamp` field? Can we use context from MLS to help with ordering messages, including in threads?",
      "createdAt": "2023-07-07T13:14:56Z",
      "updatedAt": "2024-05-08T14:59:32Z",
      "closedAt": "2024-05-08T14:59:32Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Andrew,\r\nWe don't really have email-style threads in this document, just a topic ID. I think the ordering algorithm should be the same if you are in a topic or not. A topic is just a filter.\r\n\r\nI meant to include a subsection about timestamp correlation in the Security Consideration section. I assume that the transport protocol will have some type of envelope franked with the arrival timestamp of the first server. If this server timestamp and the encrypted message both arrive at the receivers, they can compare the inner and outer timestamps and reject messages with inner timestamps that are too early or late. ",
          "createdAt": "2023-07-18T04:40:33Z",
          "updatedAt": "2023-07-18T04:40:33Z"
        },
        {
          "author": "anoadragon453",
          "authorAssociation": "NONE",
          "body": "Comparing to a timestamp set by a server sounds sensible. Using only the first server may still leave room for malice by the server operator, though I'm unsure if that is in scope of our threat model.\r\n\r\nWhy not use the timestamp of when your server/the second server received the message instead? This would also prevent a remote server who's clock was significantly off from always appearing to send messages in the past, even when they were replying to the latest message in the room.",
          "createdAt": "2023-07-26T16:29:26Z",
          "updatedAt": "2023-07-26T16:29:26Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "From IETF 119 it looks like we have consensus to use the acceptance time of the hub when it is available to the client. ",
          "createdAt": "2024-03-21T05:21:45Z",
          "updatedAt": "2024-03-21T05:21:45Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOJiBc4M5rkOKf",
      "title": "MIMI Message Syntax: Matrix's Extensible Events",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/5",
      "state": "CLOSED",
      "author": "anoadragon453",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As a whole, the semantics laid out in the adopted content format draft look sound to me. At this point I'd like to propose a syntax for how messages could concretely look.\r\n\r\n\"Matrix's Extensible Events\" is one possible syntax. It is a content format we've been developing as part of the Matrix Foundation C.I.C., and are actively looking to move the Matrix network over to in the medium term. The format is flexible, with re-usable and nestable pieces and supports clear fallback semantics.\r\n\r\nBelow is a quick overview of Matrix's Extensible Events and some examples mapping the current draft's content format semantics to it. I will be using JSON to represent these structures, but one could easily use any message format that supports similar semantics to JSON (such as CBOR ([RFC 8949](https://www.rfc-editor.org/rfc/rfc8949)), MessagePack, Protobuf, etc.).\r\n\r\n### Overview of Matrix's Extensible Events\r\n\r\nA typical \"extensible event\" looks like this:\r\n\r\n```json5\r\n{\r\n    \"type\": \"m.some.type\",\r\n    \"content\": {\r\n        <content blocks>\r\n    },\r\n    \"sender\": \"@andrewm:example.org\",\r\n    \"event_id\": \"$ct3Os0acx2nUKFTmbedS8MhPT1W1J8c2cMWyWEI0ADw\",\r\n    \"room_id\": \"!cEXuEjziVcCzbxbqmN:example.org\"\r\n}\r\n```\r\n\r\n* The `sender` field indicates what user has sent this message. This is analogous to the `senderLeafIndex` derived field in the current draft.\r\n* The `event_id` field indicates the message ID, which is unique across all rooms. This is analogous to the `MessageId` field in the current draft, except that it uses a hash of the contents to generate a unique ID, rather than \"UUID + owning provider domain\".\r\n* The `room_id` field indicates the room, or MLS Group, that this message was sent in. This is analogous to the `mlsGroupId` derived field in the current draft.\r\n* The `type` field states the type of the message. This tells the receiver what kind of content (in `content`) to expect. This is not quite analogous to the current draft, but is similar to a combination of the \"PartSemantics\" and \"Disposition\" mechanisms we currently define.\r\n* And finally, the `content` map contains zero or more \"content blocks\" that contain: the data to render, potential relations to other messages, and so forth.\r\n\r\n#### Content Blocks\r\n\r\nA \"content block\" is identified by an identifier and some renderable data. For example, this is a message of type `m.message` with a `m.text` content block:\r\n\r\n```json5\r\n{\r\n    \"type\": \"m.message\",\r\n    \"content\": {\r\n        \"m.text\": [\r\n            {\"body\": \"<i>Hello World!</i>\", \"mimetype\": \"text/html\"},\r\n            {\"body\": \"Hello world!\"}\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\nContent blocks are simply any top-level key in the `content` field. They can have any value type (that is also legal in a message generally: string, integer, etc).\r\n\r\nThe `m.text` content block is defined as an ordered array of MIME types, optional language codes and strings that together represent a single marked-up blob of text. The `mimetype` is optional and defaults to `text/plain;charset=utf-8`. The `m.message` type requires a `m.text` content block, and defines no optional content blocks.\r\n\r\nA useful property of the `m.message` *message type* and the `m.text` *content block* being defined separately is that we can reuse the latter for other message types. We can also use it when attempting to specify a rendering fallback for message types some clients may not understand.\r\n\r\n#### Rendering & Fallback\r\n\r\nWhen a client receives a message, it first looks at the `type` of the message. If it is a type that the client recognises (i.e. it supports a version of MIMI that defines the type, or a custom vendor type) then they can continue to look for the content blocks that type defines should be rendered.\r\n\r\nIf the client does not recognise the type, then it should proceed to look at the content blocks that the message contains and attempt to associate them with a message type it does know.\r\n\r\nThat culminates our fallback semantics. For example, given the following message with a custom type:\r\n\r\n```json5\r\n{\r\n    \"type\": \"com.large-vendor.location-pin\",\r\n    \"content\": {\r\n        \"com.large-vendor.location\": {\r\n            \"uri\": \"geo:51.5008,0.1247;u=35\",\r\n            \"description\": \"My current location\",\r\n            \"zoom_level\": 15\r\n        }\r\n        \"m.text\": [{\"body\": \"My current location is geo:51.5008,0.1247;u=35\"}]\r\n    },\r\n    // extra fields omitted...\r\n}\r\n```\r\n\r\nThis message has a `com.large-vendor.location` content block in it, which contains a location defined by a `geo:` URI ([RFC 5870](https://www.rfc-editor.org/rfc/rfc5870)). The name of the content block is namespaced to the vendor, allowing other vendors/users to experiment with similar content block designs without clients misinterpreting one for another.\r\n\r\nImagine you have a room with two clients in it; Large Vendor App (LVA) and Other Large Vendor App (OLVA). LVA will recognise a `com.large-vendor.location-pin` message type and render it accordingly. While OLVA may not recognise that type. In the case of OLVA, it should fall back to the other available content blocks and attempt to render a type that it does know. The priority ordering of types to try is up to the implementation.\r\n\r\nOther Large Vendor App knows that `m.message` requires a single `m.text` content block, so it will render this message as an `m.message` with the text \"My current location is geo:51.5008,0.1247;u=35\". These fallback semantics allow vendors, hobbiests and anyone else to send messages while remaining confident that other clients in the room will still be able to understand their communication.\r\n\r\n#### Nesting\r\n\r\nAlong with other similarities to a `NestablePart`, content blocks can be nested inside each other.\r\n\r\nThe `m.image` message type defines a `m.file` content block, optional `m.thumbnail`, `m.caption` and an `m.text` block (for fallback) among other blocks:\r\n\r\n```json5\r\n{\r\n  \"type\": \"m.image\",\r\n  \"content\": {\r\n    \"m.text\": [ // required - fallback for text-only clients\r\n      {\"body\": \"my-dog.png (127 KB) https://example.org/img/my-dog.png\"}\r\n    ],\r\n    \"m.file\": { // required - the image itself\r\n      \"url\": \"https://example.org/img/my-dog.png\",\r\n      \"name\": \"my-dog.png\",\r\n      \"mimetype\": \"image/png\",\r\n      \"size\": 130530\r\n    },\r\n    \"m.thumbnail\": [ // optional\r\n      {\r\n        // A thumbnail is an m.file+m.image, or a small image\r\n        \"m.file\": {\r\n          \"url\": \"https://example.org/thumb/my-dog.png\",\r\n          \"mimetype\": \"image/jpeg\",\r\n          \"size\": 1702\r\n        },\r\n        // thumbnail image dimensions omitted.\r\n      }\r\n    ]\r\n    \"m.caption\": { // optional - goes above/below image\r\n      \"m.text\": [{\"body\": \"And this is the 568th photo of my dog!\"}]\r\n    }\r\n    // other optional content blocks (alt text, image dimensions, etc.) omitted.\r\n  }\r\n}\r\n```\r\n\r\nAs `m.text` is quite a versatile content block, we can use it in many areas, even within other content blocks. The same is done for `m.file`, which is being used by `m.thumbnail` to point to a smaller resolution version of the image.\r\n\r\nThese content block should not be used just *anywhere* however - message types must define required or optional content blocks that clients should expect when rendering them. There is another kind of content block that can be used at the top-level of *any* message type though, called mixins.\r\n\r\n#### Mixin Content Blocks\r\n\r\nA \"mixin\" is a class of content block that can be added to any message type. An example of a mixin is a `m.automated` content block - for which the presence of such denotes that the message was sent by an automation rather than by a user directly. Slack, for example, uses this information to display an `APP` label next to bot messages.\r\n\r\nAnother type of mixin is `m.thread` - informing the client that a given message took place in a thread. This saves message types from all needing to define `m.thread` as an optional content block. Instead, it can be applied to any message type.\r\n\r\n#### References\r\n\r\nThere are several scenarios where a message needs to reference another message. Replies, reactions and deletions are a few examples. A `m.references` content block is an array of zero or more \"references\"; each containing the type of reference and the ID of another message.\r\n\r\nFor instance, to delete a message a client would send the following:\r\n\r\n```json5\r\n{\r\n    \"type\": \"m.delete\",\r\n    \"m.references\": [\r\n        {\r\n            \"type\": \"m.delete\",\r\n            \"message_id\": \"message_id@domain\"\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\nReceiving clients would interpret this as a past message with ID `message_id@domain` should be removed from the timeline.\r\n\r\n---\r\n\r\nUsing this system, we can translate all of the currently defined functionality (reactions, expiring, VoIP, etc.) to concrete representations. \r\n\r\nWe've already proposed a number of definitions for various message types (listed in the introduction of [MSC1767](https://github.com/matrix-org/matrix-spec-proposals/blob/matthew/msc1767/proposals/1767-extensible-events.md)), which can serve as a starting point.  \r\n\r\nThe semantics are very similar to the current content format draft. The main difference is that the receiving implementation is in full control of which content blocks it decides to process and in which order. This was done deliberately to allow for the fallback semantics, while still hinting at what content block should be rendered via the defined message type.",
      "createdAt": "2023-07-14T10:47:03Z",
      "updatedAt": "2024-10-20T22:02:02Z",
      "closedAt": "2024-10-20T22:02:02Z",
      "comments": [
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "Not sure if this is the right discussion venue for this, but I'll put my feedback here anyway ;)\r\n\r\n> The event_id field indicates the message ID, which is unique across all rooms. This is analogous to the MessageId field in the current draft.\r\n\r\nExcept that the current draft's messageId consists of two parts: a domain-unique message id and the domain.\r\n\r\n> The type field states the type of the message. This tells the receiver what kind of content (in content) to expect. This is not quite analogous to the current draft, but is similar to a combination of the \"PartSemantics\" and \"Disposition\" mechanisms we currently define.\r\n\r\nExcept that the part semantics / disposition are per part and thus allow a message to contain arbitrary multiple contents (via singleUnit/processAll semantics). It also allows for much more flexibility as e.g. a file can be marked for inline display (looking at the MSC1767 it seems to be impossible to create a new type that fallbacks to what type=m.image does, because m.image is not a content block, the behavior of m.file does not ask for the file to be displayed inline and there is no disposition field to indicate that)\r\n\r\n> When a client receives a message, it first looks at the type of the message. If it is a type that the client recognise [...] then they can continue to look for the content blocks that type defines should be rendered. If the client does not recognise the type, then it should proceed to look at the content blocks that the message contains and attempt to associate them with a message type it does know.\r\n\r\nSo essentially, the type doesn't really matter, because the receiving client will look into the content blocks nonetheless and pick any that it does support (e.g. in your example, a client that understands com.large-vendor.location content block will render that, others will render the text - even if type was `any`)\r\n\r\n> The semantics are very similar to the current content format draft. The main difference is that the receiving implementation is in full control of which content blocks it decides to process and in which order. This was done deliberately to allow for the fallback semantics, while still hinting at what content block should be rendered via the defined message type.\r\n\r\nThe current draft specifies that the order of entries in the chooseOne semantics indicate the senders preference over the different parts, but that recipient is allowed to pick any. This means the receiving entity remains in full control, but the sender's order gives essentially the feature you provide through the message type.\r\n\r\nIn summary: the current draft seems to be more powerful than the MSC1767 syntax and be more targeted to the usecase of MIMI.\r\n\r\nWhen asked for the format, I would suggest to go for something like EXI rather than JSON/CBOR/MessagePack/...: It is well extensible, has support for binary data, is generally efficient in encoding, has a reasonable plain text representation (can be converted from/to XML lossless) and also has a logic for string lookup tables, the latter could become relevant, as with the multipart system, we might see the same longer strings (like URLs) appear at multiple parts within the message.",
          "createdAt": "2023-08-03T05:42:56Z",
          "updatedAt": "2023-08-03T15:24:58Z"
        },
        {
          "author": "anoadragon453",
          "authorAssociation": "NONE",
          "body": "> > The event_id field indicates the message ID, which is unique across all rooms. This is analogous to the MessageId field in the current draft.\r\n> \r\n> Except that the current draft's messageId consists of two parts: a domain-unique message id and the domain.\r\n\r\nYes, I was confused between the ID of an event at the transport layer (what the \"Event ID\" in my proposal referred to), and a message ID inside the MLS application message. Depending on how the transport layer develops, these two IDs may end up being the same value, but for now that's up in the air (blocked on the transport side).\r\n\r\nIn Matrix the [Event ID](https://spec.matrix.org/v1.7/rooms/v10/#event-ids) is derived from a hash of some of the fields in the message, which include the domain name. Thus the domain name need not be included directly in the ID.\r\n\r\nRegardless, that change should be discussed separately. I'll update the post to mention the difference as pointed out.\r\n\r\n> > The type field states the type of the message. This tells the receiver what kind of content (in content) to expect. This is not quite analogous to the current draft, but is similar to a combination of the \"PartSemantics\" and \"Disposition\" mechanisms we currently define.\r\n\r\n> It also allows for much more flexibility as e.g. a file can be marked for inline display\r\n\r\nJust to make sure i understand this correctly, would this translate to e.g. an ODT file being rendered inside the timeline of the room? That might be a case of the receiving client deciding whether to do so for an `m.file` based on the `mimetype`?\r\n\r\n> (looking at the MSC1767 it seems to be impossible to create a new type that fallbacks to what type=m.image does, because m.image is not a content block, the behavior of m.file does not ask for the file to be displayed inline and there is no disposition field to indicate that)\r\n\r\nIf all the necessary content blocks of an `m.image` type are present (`m.file`, `m.text`), then ideally you would be able to fall back. The problem I see is that there is already an `m.file` there being used for the video. One solution to solve this is to use an `m.image_details` content block, with an `m.file` nested inside of it. Then you would not have a conflict between two top-level `m.file` content blocks. Still, that conflict feels like a valid limitation. The current draft gets around this by nesting *everything*.\r\n\r\n> > When a client receives a message, it first looks at the type of the message. If it is a type that the client recognise [...] then they can continue to look for the content blocks that type defines should be rendered. If the client does not recognise the type, then it should proceed to look at the content blocks that the message contains and attempt to associate them with a message type it does know.\r\n> \r\n> So essentially, the type doesn't really matter, because the receiving client will look into the content blocks nonetheless and pick any that it does support (e.g. in your example, a client that understands com.large-vendor.location content block will render that, others will render the text - even if type was `any`)\r\n\r\nTypes do help in the case where you have two or separate events which share the same set of required content blocks, but that you'd want to render differently. For instance, the types [`m.video`](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/video/proposals/3553-extensible-events-video.md), [`m.image`](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/images/proposals/3552-extensible-events-images.md), [`m.audio`](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/audio/proposals/3927-extensible-events-audio.md) and [`m.file`](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/files/proposals/3551-extensible-events-files.md) all only require the `m.file` and `m.text` content blocks. The `type` informs the receiving client what the sender intended to have rendered. Of course if a client didn't understand `m.audio`, it could fall back to `m.file` (just displaying a file download) or even just `m.text`.\r\n\r\nNow `m.file` does have a (optional) `mimetype` field, and a receiving client could use this instead to determine whether to show a video player/audio player/etc. This is essentially the route that the current draft proposal takes. But it does mean the client needs to use heuristics such as checking against a list of mimetypes in order to know what content to render, rather than an explicit `m.video` vs. `m.audio` type. We'd need to make similar exceptions (with different fields to check) for other groups of types that require the same content blocks.\r\n\r\nIt's also important to note that its up to the receiving client to decide the known types they would and would not fall back to. For instance, I suspect clients will not want to fallback to a poll type.\r\n\r\n> > The semantics are very similar to the current content format draft. The main difference is that the receiving implementation is in full control of which content blocks it decides to process and in which order. This was done deliberately to allow for the fallback semantics, while still hinting at what content block should be rendered via the defined message type.\r\n> \r\n> The current draft specifies that the order of entries in the chooseOne semantics indicate the senders preference over the different parts, but that recipient is allowed to pick any. This means the receiving entity remains in full control, but the sender's order gives essentially the feature you provide through the message type.\r\n\r\nGood point! Looking at this again, I don't think there's any inherit benefit over the current draft in terms of priority of fallbacks in an event.\r\n\r\n> When asked for the format, I would suggest to go for something like EXI rather than JSON/CBOR/MessagePack/...: It is well extensible, has support for binary data, is generally efficient in encoding, has a reasonable plain text representation (can be converted from/to XML lossless) and also has a logic for string lookup tables, the latter could become relevant, as with the multipart system, we might see the same longer strings (like URLs) appear at multiple parts within the message.\r\n\r\nInteresting, thank you. I've not heard of this format before - I'll need to take a look!",
          "createdAt": "2023-08-07T11:35:49Z",
          "updatedAt": "2023-08-07T11:35:49Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "> Just to make sure i understand this correctly, would this translate to e.g. an ODT file being rendered inside the timeline of the room? That might be a case of the receiving client deciding whether to do so for an m.file based on the mimetype?\r\n> \r\n> Types do help in the case where you have two or separate events which share the same set of required content blocks, but that you'd want to render differently. For instance, the types [m.video](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/video/proposals/3553-extensible-events-video.md), [m.image](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/images/proposals/3552-extensible-events-images.md), [m.audio](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/audio/proposals/3927-extensible-events-audio.md) and [m.file](https://github.com/matrix-org/matrix-spec-proposals/blob/travis/msc/extev/files/proposals/3551-extensible-events-files.md) all only require the m.file and m.text content blocks. The type informs the receiving client what the sender intended to have rendered. Of course if a client didn't understand m.audio, it could fall back to m.file (just displaying a file download) or even just m.text.\r\n>\r\n> Now m.file does have a (optional) mimetype field, and a receiving client could use this instead to determine whether to show a video player/audio player/etc. This is essentially the route that the current draft proposal takes. But it does mean the client needs to use heuristics such as checking against a list of mimetypes in order to know what content to render, rather than an explicit m.video vs. m.audio type. We'd need to make similar exceptions (with different fields to check) for other groups of types that require the same content blocks.\r\n\r\nI fail to follow your reasoning here:\r\n- The receiving client must be able to determine if and how they can render a file in any case. It doesn't help that the sending client set type to `m.image` and mimetype to `image/emf` if the receiving client does not support the Enhanced Metafile format. So the type (just as any of the values for disposition) is no more than a hint to the recipient client how the sender envisioned to transfer the file, but any reasonable client should probably fallback to have support to download the file, so that the user can open it with an external application (except maybe in cases where we explicitly want to make sure that the file is not downloaded/copied, thinking of messages that destroy themselves after a timeout).\r\n- You wrote that the receiving client can decide to display a file inline for `m.file` (in the example of an ODT), what makes `m.image` then different from `m.file`? In both cases it is up to the receiving client to decide what disposition to use (although with `m.image` there is a strong hint from the sender that they envision the file to be displayed inline).\r\n- The terms `audio`/`video`/`image` match exactly the toplevel MIME type, so if you're looking for a \"heuristic\" when to behave as if it was `m.audio`/`m.video`/`m.image`, that would be very trivial.\r\n- In the respective MSC, the authors seem to make the assumption that only video and image files can have thumbnails. I'd very much question this, as I can well imagine thumbnails for audio (e.g. album cover, waveform) or documents (e.g. thumbnail of the first page of a pdf) and probably way more. The current draft allows files with disposition of preview no matter the mime type of other parts.",
          "createdAt": "2023-08-07T12:22:55Z",
          "updatedAt": "2023-08-08T18:45:36Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the format has been pretty stable for some time and has a few implementers at this point. I'm going to close this as just too different from what we implemented without demonstrating unsolvable requirements. ",
          "createdAt": "2024-10-20T22:02:02Z",
          "updatedAt": "2024-10-20T22:02:02Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJiBc4M52U4Vj",
      "title": "External attachments need a hash of content",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/6",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As specified, the external content mechanism just contains an AEAD key that is used to encrypt the external content. The problem with this design is that it allows any receiver of the message to collude with the storage server to replace the content, because the key is sufficient to create a valid piece of external content.\r\n\r\nThe fix for this is to have a separate hash of the content in the external content reference; this prevents an attacker from substituting the content.",
      "createdAt": "2023-11-09T09:16:34Z",
      "updatedAt": "2024-04-23T21:55:35Z",
      "closedAt": "2024-04-23T21:55:34Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "added this to the concrete TLS PL syntax in commit https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/commit/8d4eada51846fa6f31a33e1d701f86ad3471ddf3 Lines 431-432.\r\n\r\nNormative text coming in another commit.",
          "createdAt": "2024-04-07T20:05:06Z",
          "updatedAt": "2024-04-07T20:05:06Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Also included in the CBOR syntax.\r\n\r\nSubmitted draft -03 with this fix.",
          "createdAt": "2024-04-23T21:55:35Z",
          "updatedAt": "2024-04-23T21:55:35Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJiBc4M59Zbeh",
      "title": "MimiContent should have optional Subject text field",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/7",
      "state": "CLOSED",
      "author": "RonPeters",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Most of the time we do not think of subject lines for chat-style messaging, but there are many instances where subject lines are currently allowed (both inline and in threaded chats). For instance, iMessage, Microsoft Teams, and even MMS all allow subject lines. I believe it should be added as an optional field in MimiContent for feature parity.",
      "createdAt": "2024-01-27T21:24:53Z",
      "updatedAt": "2024-10-20T22:05:04Z",
      "closedAt": "2024-10-20T22:05:04Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Ron,\r\nI am moderately skeptical of, but not inherently opposed to, a Subject field for MIMI content.\r\n\r\nI have a few questions. The first is what the semantics would be of the field. Is this the subject of the conversation/room, or the subject of the specific message?  If it is the subject of the room, it probably doesn't belong in this content format, but more likely in the room state.\r\n\r\nWould it ever be used to organize threads of messages?  How would its use relate to the `topicId` field?\r\n\r\nNext, do we have any information on how common is it that someone actually set a per-message Subject in iMessage or Teams? In the case of MMS, most clients don't have a UI that allows someone to set a per-message Subject, so I don't find the MMS argument especially compelling for inclusion in MIMI content.",
          "createdAt": "2024-02-07T22:11:21Z",
          "updatedAt": "2024-02-07T22:11:21Z"
        },
        {
          "author": "RonPeters",
          "authorAssociation": "NONE",
          "body": "Hi Rohan,\r\n\r\nThank you for considering. I believe it is a bit of an outlier, but corresponds to some useful real-world contexts.\r\n\r\nFor instance, in Teams, a post in a team discussion (as opposed to a direct chat) can have an optional subject line. Replies to that post become threaded and is very useful for organizing threads. I believe this would correspond to setting a subject on the first message with a particular topicId.\r\n\r\nRegarding mobile clients, both iMessage and Google Messages have simple ways of enabling subject lines in the UI. Although I expect the actual usage is likely low, but it is there.\r\n\r\n-Ron\r\n\r\n________________________________\r\nFrom: rohan-wire ***@***.***>\r\nSent: Wednesday, February 7, 2024 2:11 PM\r\nTo: ietf-wg-mimi/draft-ietf-mimi-content ***@***.***>\r\nCc: Ron Peters ***@***.***>; Author ***@***.***>\r\nSubject: Re: [ietf-wg-mimi/draft-ietf-mimi-content] MimiContent should have optional Subject text field (Issue #7)\r\n\r\n\r\nHi Ron,\r\nI am moderately skeptical of, but not inherently opposed to, a Subject field for MIMI content.\r\n\r\nI have a few questions. The first is what the semantics would be of the field. Is this the subject of the conversation/room, or the subject of the specific message? If it is the subject of the room, it probably doesn't belong in this content format, but more likely in the room state.\r\n\r\nWould it ever be used to organize threads of messages? How would its use relate to the topicId field?\r\n\r\nNext, do we have any information on how common is it that someone actually set a per-message Subject in iMessage or Teams? In the case of MMS, most clients don't have a UI that allows someone to set a per-message Subject, so I don't find the MMS argument especially compelling for inclusion in MIMI content.\r\n\r\n\u2014\r\n\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/7#issuecomment-1933022002>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ASF44GP37KBRIPHYAHVAHFDYSP3ZJAVCNFSM6AAAAABCNUH5SGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMZTGAZDEMBQGI>.\r\n\r\nYou are receiving this because you authored the thread.\r\n",
          "createdAt": "2024-02-08T01:43:57Z",
          "updatedAt": "2024-02-08T01:43:57Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi,\r\nI think the Teams use case you described can be implemented with the\r\ntopicId.\r\n\r\nI think the iMessage/MMS use case is to set the subject for the\r\n\"conversation\" and not per message, but I could be wrong on that.\r\nThanks,\r\n-rohan\r\n\r\nOn Wed, Feb 7, 2024, 17:44 Ron Peters ***@***.***> wrote:\r\n\r\n> Hi Rohan,\r\n>\r\n> Thank you for considering. I believe it is a bit of an outlier, but\r\n> corresponds to some useful real-world contexts.\r\n>\r\n> For instance, in Teams, a post in a team discussion (as opposed to a\r\n> direct chat) can have an optional subject line. Replies to that post become\r\n> threaded and is very useful for organizing threads. I believe this would\r\n> correspond to setting a subject on the first message with a particular\r\n> topicId.\r\n>\r\n> Regarding mobile clients, both iMessage and Google Messages have simple\r\n> ways of enabling subject lines in the UI. Although I expect the actual\r\n> usage is likely low, but it is there.\r\n>\r\n> -Ron\r\n>\r\n> ________________________________\r\n> From: rohan-wire ***@***.***>\r\n> Sent: Wednesday, February 7, 2024 2:11 PM\r\n> To: ietf-wg-mimi/draft-ietf-mimi-content ***@***.***>\r\n> Cc: Ron Peters ***@***.***>; Author ***@***.***>\r\n> Subject: Re: [ietf-wg-mimi/draft-ietf-mimi-content] MimiContent should\r\n> have optional Subject text field (Issue #7)\r\n>\r\n>\r\n> Hi Ron,\r\n> I am moderately skeptical of, but not inherently opposed to, a Subject\r\n> field for MIMI content.\r\n>\r\n> I have a few questions. The first is what the semantics would be of the\r\n> field. Is this the subject of the conversation/room, or the subject of the\r\n> specific message? If it is the subject of the room, it probably doesn't\r\n> belong in this content format, but more likely in the room state.\r\n>\r\n> Would it ever be used to organize threads of messages? How would its use\r\n> relate to the topicId field?\r\n>\r\n> Next, do we have any information on how common is it that someone actually\r\n> set a per-message Subject in iMessage or Teams? In the case of MMS, most\r\n> clients don't have a UI that allows someone to set a per-message Subject,\r\n> so I don't find the MMS argument especially compelling for inclusion in\r\n> MIMI content.\r\n>\r\n> \u2014\r\n>\r\n> Reply to this email directly, view it on GitHub<\r\n> https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/7#issuecomment-1933022002>,\r\n> or unsubscribe<\r\n> https://github.com/notifications/unsubscribe-auth/ASF44GP37KBRIPHYAHVAHFDYSP3ZJAVCNFSM6AAAAABCNUH5SGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMZTGAZDEMBQGI>.\r\n>\r\n>\r\n> You are receiving this because you authored the thread.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/7#issuecomment-1933234033>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AVXAIJ6ON4JFWTHANHPTJ4TYSQUWRAVCNFSM6AAAAABCNUH5SGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTSMZTGIZTIMBTGM>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2024-02-08T02:06:49Z",
          "updatedAt": "2024-02-08T02:06:49Z"
        },
        {
          "author": "RonPeters",
          "authorAssociation": "NONE",
          "body": "Hi Rohan,\r\n\r\nIn the Teams case, the topicId is just an identifier (like a \"thread ID\"), not a human-readable string, correct? So I don't see how that fulfils the object of having a subject line for the thread.\r\n\r\nRegarding the MMS case, both iMessage and Google Messages allow setting the subject for an individual message. The Google Messages UX is deficient, in my opinion, because the menu item seems to be associated with the conversation, but the actual action is to enable the subject line for the next message you send.\r\n\r\nRegards,\r\n-Ron",
          "createdAt": "2024-02-08T02:24:16Z",
          "updatedAt": "2024-03-22T02:09:55Z"
        },
        {
          "author": "RonPeters",
          "authorAssociation": "NONE",
          "body": "I just watched the IETF 119 MIMI meeting. I only brought up Subject as a field because perhaps I did not understand the extensibility points in MIMI. I would much rather have Subject be some kind of extension to the message, but I'm not sure where that would fall in the spec. Would it be a \"SubjectPart\"? In any case, I am all for using extensibility to address this.\r\n\r\nRegards,\r\nRon",
          "createdAt": "2024-03-22T00:30:15Z",
          "updatedAt": "2024-03-22T02:09:37Z"
        },
        {
          "author": "RonPeters",
          "authorAssociation": "NONE",
          "body": "Thinking some more, I guess it could be a Disposition type",
          "createdAt": "2024-03-22T06:24:44Z",
          "updatedAt": "2024-03-22T06:24:44Z"
        },
        {
          "author": "RonPeters",
          "authorAssociation": "NONE",
          "body": "Or, I guess it could be a SinglePart with embedded RDF:\r\n\r\n```\r\ncontentType: application/json+ld\r\ncontent:\r\n{\r\n    \"@context\": \"https://schema.org\",\r\n    \"@type\": \"Message\",\r\n    \"name\": \"Example Subject\"\r\n}\r\n```\r\n\r\nWould this be an appropriate direction? I definitely don't want to burden the spec with edge cases. I'm just looking for an acceptable way to carry the data in the payload.",
          "createdAt": "2024-03-22T18:40:26Z",
          "updatedAt": "2024-03-22T18:57:32Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Ron,\r\nIf you want this to be the subject of a message, you couldn't use\r\nSinglePart. You could have a two parts bound together, but I think for an\r\nobject that describes the message, I think having a clear extensibility\r\nscheme will be easier with a concrete syntax will be easier. I should have\r\nconcrete TLS Presentation Language and CBOR syntaxes within a few weeks.\r\nThanks,\r\n-rohan\r\n\r\nOn Sat, Mar 23, 2024, 04:40 Ron Peters ***@***.***> wrote:\r\n\r\n> Or, I guess it could be a SinglePart with embedded RDF:\r\n>\r\n> contentType: application/json+ld\r\n> content:\r\n> {\r\n>     ***@***.***\": \"https://schema.org\",\r\n>     ***@***.***\": \"Message\",\r\n>     \"about\": {\r\n>         ***@***.***\": \"Thing\",\r\n>         \"name\": \"Example Subject\"\r\n>     }\r\n> }\r\n>\r\n> Would this be an appropriate direction? I definitely don't want to burden\r\n> the spec with edge cases. I'm just looking for an acceptable way to carry\r\n> the data in the payload.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/7#issuecomment-2015699107>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AADSQPSMWKFBRMWZO7LFYU3YZR3LBAVCNFSM6AAAAABCNUH5SGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDAMJVGY4TSMJQG4>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2024-03-23T00:18:54Z",
          "updatedAt": "2024-03-23T00:18:54Z"
        },
        {
          "author": "RonPeters",
          "authorAssociation": "NONE",
          "body": "Hi Rohan,\r\n\r\nAgreed that clear extensibility is the best solution. I thought perhaps I had missed something in the existing spec, so I appreciate your consideration and I look forward to seeing it in future revisions.\r\n\r\nRegards,\r\n-Ron",
          "createdAt": "2024-03-23T00:48:29Z",
          "updatedAt": "2024-03-23T00:48:29Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, there are two mechanisms that could be used for conveying subject in the current framework: a) add a custom map item to the extensions map in the message, or b) create a custom media type to carry this (and possibly other) kinds of hints/metadata and add it to the message.\r\n\r\nClosing. ",
          "createdAt": "2024-10-20T22:05:04Z",
          "updatedAt": "2024-10-20T22:05:04Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJiBc4M6C6NcA",
      "title": "While using c++ syntax, should use std::optional",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/8",
      "state": "CLOSED",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A number of fields in the abstract syntax have descriptions with words like \"does not expire if zero\", \"if the topic field is empty, there is no such grouping\".\r\n\r\nThe description will be clearer, and easier to translate into a new concrete syntax when we decide upon one, if we use std::optional<type> instead of \"type with comment saying when it's empty\".\r\n",
      "createdAt": "2024-03-20T00:02:43Z",
      "updatedAt": "2024-04-23T21:54:32Z",
      "closedAt": "2024-04-23T21:54:31Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Harald,\r\nAs of draft -03 we are no longer using C++ syntax. We have a TLS PL and CBOR syntax and need to pick one.\r\n\r\nClosing.",
          "createdAt": "2024-04-23T21:54:32Z",
          "updatedAt": "2024-04-23T21:54:32Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJiBc4M6DFDkR",
      "title": "Convert abstract syntax to concrete syntax",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/10",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Agreed at IETF119 to make the examples in the draft use TLS Presentation Language with a Appendix showing the Examples encoded in CBOR.",
      "createdAt": "2024-03-21T05:16:29Z",
      "updatedAt": "2024-04-23T21:54:55Z",
      "closedAt": "2024-04-23T21:54:55Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Done. Submitted in -03",
          "createdAt": "2024-04-23T21:54:55Z",
          "updatedAt": "2024-04-23T21:54:55Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOJiBc4M6GsXDI",
      "title": "Add rest of multi-part body examples",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/11",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-23T21:12:49Z",
      "updatedAt": "2024-06-09T16:42:54Z",
      "closedAt": "2024-06-09T16:42:54Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with PR #17 . Closing. ",
          "createdAt": "2024-06-09T16:42:49Z",
          "updatedAt": "2024-06-09T16:42:49Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOJiBc4M6GsXKh",
      "title": "For CBOR encoding decide if we want to tag URIs",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/12",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "",
      "createdAt": "2024-04-23T21:13:15Z",
      "updatedAt": "2024-12-18T19:31:49Z",
      "closedAt": "2024-12-18T19:31:49Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Nobody has made any objection to tagging. It's only one octet per URI. Will close in 2 weeks unless there is an objection",
          "createdAt": "2024-06-05T17:06:52Z",
          "updatedAt": "2024-06-05T17:06:52Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "NONE",
          "body": "Can we get more information or an example of what this means?",
          "createdAt": "2024-06-05T17:30:54Z",
          "updatedAt": "2024-06-05T17:30:54Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "CBOR Web Tokens use URLs for the Issuer and Audience. The spec says specifically NOT to include a tag because the semantics of those fields clearly indicates the contents are a URL.\r\n\r\nConclusion. Don't add a URL tag to fields that are always a URL.",
          "createdAt": "2024-11-07T08:55:00Z",
          "updatedAt": "2024-11-07T08:55:00Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2024-12-18T19:31:49Z",
          "updatedAt": "2024-12-18T19:31:49Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOJiBc4M6GsZTE",
      "title": "For CBOR encoding, decide if timestamps should use time tags",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/13",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "needs consensus",
        "has-PR"
      ],
      "body": "Should the Timestamp be?\r\n\r\na) a uint64 with no tag:  unit .size 8\r\nb) a uint64 with new tag: ex: 62(uint .size 8)\r\nc) use [time tags](https://www.ietf.org/archive/id/draft-ietf-cbor-time-tag-12.html) with a base time of integer and a number of additional milliseconds.",
      "createdAt": "2024-04-23T21:17:49Z",
      "updatedAt": "2025-02-26T18:59:06Z",
      "closedAt": "2025-02-26T18:59:06Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "We need to decide what the time stamp is based on whatever value we get from the MIMI protocol, which currently is just an integer number of milliseconds. It doesn't make sense to add a tag unless the TLS struct for timestamp in mimi-protocol has multiple options (ex: can optionally express sub-millisecond resolution).",
          "createdAt": "2024-11-07T08:57:06Z",
          "updatedAt": "2024-11-07T08:57:06Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "In #46, I made a change to the CDDL to allow EITHER an integer number of milliseconds since the UNIX epoch, OR a CBOR Extended Time Tag 1001 with the time values from RFC9581. With that I propose we close this issue.",
          "createdAt": "2025-02-24T20:17:27Z",
          "updatedAt": "2025-02-24T20:17:27Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOJiBc4M6IPooQ",
      "title": "Decide if we use CBOR or TLS Presentation Language",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/14",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2024-05-08T14:50:16Z",
      "updatedAt": "2024-06-05T17:00:57Z",
      "closedAt": "2024-06-05T17:00:57Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "We discussed this at a [recent MIMI interim](https://datatracker.ietf.org/doc/minutes-interim-2024-mimi-03-202405081600/) and the held a [consensus call on the mailing list](https://mailarchive.ietf.org/arch/msg/mimi/L6CEupXf74lJ5_KuUoq6ipl-eik/). The conclusion is that we will be using CBOR. Let's repurpose this issue to track making that change to draft-ietf-mimi-content.",
          "createdAt": "2024-05-23T16:50:38Z",
          "updatedAt": "2024-05-23T16:50:38Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "CBOR version is being updated in PR #16. Closing.",
          "createdAt": "2024-06-05T17:00:57Z",
          "updatedAt": "2024-06-05T17:00:57Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOJiBc4M6IPr6S",
      "title": "Do we need a stronger hash for In reply to? for External content hash? for the message ID?",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/15",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "CNSA 2.0 and other security guidelines no longer [recommend](https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF) SHA-256.\r\n\r\n## In Reply To\r\n\r\nShould we make the default hash SHA-384 instead of SHA-256?\r\n\r\n## External content\r\n\r\nShould we make the default hash SHA-384 instead of SHA-256?\r\n\r\n## Message ID\r\n\r\nCurrently the Message ID is the SHA-256 of the ciphertext of the message.The goal was to have a fixed length field\r\n\r\nOptions:\r\n- Keep it SHA-256\r\n- Make is the first 32 octets of the SHA-384 hash\r\n- Make it the entire SHA-384 hash\r\n- Make it a variable length so it can grow (but need to add down negotiation prevention)\r\n\r\n",
      "createdAt": "2024-05-08T14:56:49Z",
      "updatedAt": "2024-06-05T17:07:48Z",
      "closedAt": "2024-06-05T17:07:47Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "The conclusion from MIMI interim on 8-May-2024 of everyone who commented was that we should ignore this issue for now and continue to use SHA-256 unless/until someone from another IETF or IRTF explains why this is necessary.",
          "createdAt": "2024-05-08T17:45:26Z",
          "updatedAt": "2024-05-08T17:45:26Z"
        },
        {
          "author": "turt2live",
          "authorAssociation": "NONE",
          "body": "I wasn't at the interim (sorry), but +1 to sticking with sha256 until there's a good argument otherwise.",
          "createdAt": "2024-05-11T02:24:40Z",
          "updatedAt": "2024-05-11T02:24:40Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Strong consensus to keeping SHA256. Marking as closed.",
          "createdAt": "2024-06-05T17:07:47Z",
          "updatedAt": "2024-06-05T17:07:47Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOJiBc4M6LndN0",
      "title": "For CBOR Nested Part use CBOR embedding or a CBOR sequence",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/18",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed"
      ],
      "body": "The multipart examples show that there are too many nested arrays. Each NestedPart could be a CBOR sequence or embedded CBOR. This would make the EDN and Pretty printed CBOR more readable.",
      "createdAt": "2024-06-09T16:44:45Z",
      "updatedAt": "2024-12-18T19:32:15Z",
      "closedAt": "2024-12-18T19:32:15Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I could not make this work without a loss of functionality. Propose we close this issue with no action.",
          "createdAt": "2024-12-18T16:44:46Z",
          "updatedAt": "2024-12-18T16:44:46Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOJiBc4M6Y2esV",
      "title": "Add optional filename in ExternalPart",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/20",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When referencing external content that was an uploaded file/attachment, it is useful to provide a suggested filename.",
      "createdAt": "2024-10-03T16:00:47Z",
      "updatedAt": "2024-10-20T21:54:47Z",
      "closedAt": "2024-10-20T21:54:46Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #21. Clsoing.",
          "createdAt": "2024-10-20T21:54:46Z",
          "updatedAt": "2024-10-20T21:54:46Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOJiBc4M6b9U5q",
      "title": "Support relative expiration times",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/22",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "The current syntax allows expiration of messages at absolute times. However, self-deleting messages are more frequently implemented as an amount of time after the message is rendered to the user. It would be relatively straightforward to allow any message to use either an absolute or a relative expiration time. ",
      "createdAt": "2024-10-27T11:53:52Z",
      "updatedAt": "2024-12-18T19:32:59Z",
      "closedAt": "2024-12-18T19:32:58Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "POR is to support both absolute and relative expiration dates in the next draft.",
          "createdAt": "2024-12-04T17:49:02Z",
          "updatedAt": "2024-12-04T17:49:02Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed. See also new issue #39 about expiration extensibility.",
          "createdAt": "2024-12-18T19:32:58Z",
          "updatedAt": "2024-12-18T19:32:58Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOJiBc4M6b9WWc",
      "title": "Give additional guidance on Github Flavored Markdown",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/23",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "From timo:\r\n\r\nUsing https://github.github.com/gfm/ as a basis, I have identified the following problems with GFM:\r\n\r\n- Some useful features are extensions: If we go with GFM, we should at least specify what extensions to use\r\n- We do not want syntax for inline media: Instead, use MIMI MultiPart\r\n- We do not want syntax for raw html: This increases the scope a lot, since GFM does not define a whitelist. Clients would also need to impose additional security constraints.\r\n- No smart timestamps that respect timezones (see https://discord.com/developers/docs/reference#message-formatting-timestamp-styles )\r\n- No built-in interactive elements like polls.\r\n- \"Soft line breaks\" may be ignored (decided by renderer): If the user typed a newline, they probably want a newline\r\n- Ordered lists must increment by 1 and strip leading zeros 001 -> 1: Markup languages should not change the meaning of the input\r\n- No spoiler syntax for messages or media: In Discord it is ||secret||\r\n- No autolinks for mimi://\r\n- ~~Emojis can have different meanings between platforms, like gun vs water pistol: Maybe clients can annotate what emoji style they use?~~\r\n\r\nI also thought about math support, but I think that should not be part of the text message and instead be a different MIMI MultiPart entry of another content type.",
      "createdAt": "2024-10-27T12:04:43Z",
      "updatedAt": "2025-02-12T18:33:20Z",
      "closedAt": "2024-12-18T19:39:06Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "The emoji issue is clear. Unicode describes the semantics of an emoji, not it's presentation.",
          "createdAt": "2024-11-07T09:00:11Z",
          "updatedAt": "2024-11-07T09:00:11Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Rohan to paste in discussion on the mailing list and add it to the document",
          "createdAt": "2024-12-04T17:49:31Z",
          "updatedAt": "2024-12-04T17:49:31Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Walking through the remaining suggestions:\r\n>Some useful features are extensions: If we go with GFM, we should at least specify what extensions to use\r\nI plan to specify Tables, Task Lists, and Strikethrough\r\n\r\n>We do not want syntax for inline media: Instead, use MIMI MultiPart\r\nI don't understand what part fo GFM you don't want to support here. The image syntax requires a URL. It doesn't have a way to include inline images unless you use a data: URI for example. I also think it is perfectly OK for someone to include a URL in markdown in MIMI.\r\n\r\n>We do not want syntax for raw html: This increases the scope a lot, since GFM does not define a whitelist. Clients would also need to impose additional security constraints.\r\nremoved\r\n\r\n>No smart timestamps that respect timezones (see https://discord.com/developers/docs/reference#message-formatting-timestamp-styles )\r\n>No built-in interactive elements like polls.\r\n>No spoiler syntax for messages or media: In Discord it is ||secret||\r\nThese are extensions and not defined in the reference to GFM\r\n\r\n>\"Soft line breaks\" may be ignored (decided by renderer): If the user typed a newline, they probably want a newline\r\n>Ordered lists must increment by 1 and strip leading zeros 001 -> 1: Markup languages should not change the meaning of the input\r\nI think these two are confusing what was input and the Markdown sent over the wire. What is sent over the wire should be processed according to the spec. If we change the newline or ordered list handling we will be down deep in the guts of any library that supports GFM.\r\n\r\n>No autolinks for mimi://\r\nI think autolinks of mimi URLs inside < and > are perfectly OK. Since we don't support the \"extended\" autolinks extension, I think we are OK.",
          "createdAt": "2024-12-09T20:41:59Z",
          "updatedAt": "2024-12-09T20:41:59Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> [Polls, spoilers, smart timestamps, ...] are extensions and not defined in the reference to GFM\r\n\r\nShould Mimi still give guidance on this? Should we allow clients to agree on a set of extensions using room policy?\r\n\r\n> I think these two are confusing what was input and the Markdown sent over the wire.\r\n\r\nYou are right, some of the issues can be handled if we add a translation layer between user input and transmitted markdown. However, not all of them:\r\n`Ordered lists must increment by 1 and strip leading zeros 001 -> 1`\r\nWhat if the user wants to send an ordered list that increases by 10?\r\n\r\n> will be down deep in the guts of any library that supports GFM\r\n\r\nWould you still be interested in exploring this option?\r\n\r\nP.S. Ironically, in your message you did not leave an empty line between quote and response, making it harder to read. GFM has some problems.",
          "createdAt": "2024-12-17T13:59:31Z",
          "updatedAt": "2024-12-17T14:04:11Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Re: Extensions, someone can define a new variant that has other extensions, but I think it will be called something else. The point of GFM is that it is relatively well documented.\r\n\r\n> What if the user wants to send an ordered list that increases by 10?\r\nI am ok saying they can use HTML, or they can use a code block. Doing that isn't a feature of GFM markdown.\r\n\r\nRegarding the empty line, the GFM spec actually mentions that not having this line is often deisrable, and I happen to agree. Chacun \u00e0 son gout.\r\n\r\n",
          "createdAt": "2024-12-17T20:52:06Z",
          "updatedAt": "2024-12-17T20:52:06Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "As a side note: The [registration for the text/markdown media type](https://www.iana.org/assignments/media-types/text/markdown) from RFC 7763 declares the following applications to use this media type:\r\n> Markdown conversion tools, Markdown WYSIWYG editors, and plain text editors and viewers; markup processor targets indirectly use Markdown (e.g., web browsers for Markdown converted to HTML).\r\n\r\nFurther, RFC 7763 says:\r\n> The paradigmatic use case for text/markdown is the Markdown editor: an application that presents Markdown content (which looks like an email or other piece of plain-text writing) alongside a published format, so that an author can see results instantaneously and can tweak his or her input in real time.\r\n\r\nSo, following from that, I would assume that if text/markdown is included in the messages, it is for further editing the message, not for the receiving client to process and display it. For displaying, we should include a format suitable for publication in the message (RFC 7763 seems to suggest HTML for that, but other formats might be suitable as well). This would mean a rich message that is edited as markdown would then have three representations: \r\n- text/plain - as fallback for text-only clients\r\n- text/html or any other suitable publishing format - for display\r\n- text/markdown;variant=GFM or any other variant - for editing\r\n\r\nThis has the further advantage that slight differences in the markdown processing does not cause different clients to display different messages, because only the sending client would process the markdown, so the sending user knows and sees exactly how it is processed.\r\n\r\nThis also matches more the behavior of several popular instant messaging apps, that allow input using markdown but use a different format for sending.",
          "createdAt": "2024-12-18T11:30:40Z",
          "updatedAt": "2024-12-18T11:32:53Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed. defined GFM-MIMI variant. This is just GFM with no Autolinks and no raw HTML of any kind (instead of tagfilter)",
          "createdAt": "2024-12-18T19:39:06Z",
          "updatedAt": "2024-12-18T19:39:06Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: Ordered lists must always increase by 1\n\nI found a workaround that works in the default gfm. Switching the ordered list character between `.` and `)` starts a new list with a new start index. This can be used to write lists like this:\n\n```\n1. aaa\n3. ccc\n2. ddd\n100. eee\n1. fff\n\n---\n\n1. aaa\n3) ccc\n2. ddd\n100) eee\n1. fff\n```\n\n1. aaa\n3. ccc\n2. ddd\n100. eee\n1. fff\n\n---\n\n1. aaa\n3) ccc\n2. ddd\n100) eee\n1. fff\n",
          "createdAt": "2025-02-04T11:09:47Z",
          "updatedAt": "2025-02-04T11:09:47Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Excellent piece of detective work!\r\nthanks,\r\n-r\r\n\r\nOn Tue, Feb 4, 2025, 03:10 Timo K\u00f6sters ***@***.***> wrote:\r\n\r\n> Re: Ordered lists must always increase by 1\r\n>\r\n> I found a workaround that works in the default gfm. Switching the ordered\r\n> list character between . and ) starts a new list with a new start index.\r\n> This can be used to write lists like this:\r\n>\r\n> 1. aaa\r\n> 3. ccc\r\n> 2. ddd\r\n> 100. eee\r\n> 1. fff\r\n>\r\n> ---\r\n>\r\n> 1. aaa\r\n> 3) ccc\r\n> 2. ddd\r\n> 100) eee\r\n> 1. fff\r\n>\r\n>\r\n>    1. aaa\r\n>    2. ccc\r\n>    3. ddd\r\n>    4. eee\r\n>    5. fff\r\n>\r\n> ------------------------------\r\n>\r\n>    1. aaa\r\n>\r\n>\r\n>    3. ccc\r\n>\r\n>\r\n>    2. ddd\r\n>\r\n>\r\n>    100. eee\r\n>\r\n>\r\n>    1. fff\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/23#issuecomment-2633586934>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AADSQPW77NK3HTSLVP445HL2OCNZDAVCNFSM6AAAAABQVYEJUGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDMMZTGU4DMOJTGQ>\r\n> .\r\n> You are receiving this because you modified the open/close state.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2025-02-04T13:19:17Z",
          "updatedAt": "2025-02-04T13:19:17Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see three unresolved points from my list:\n\n> No spoiler syntax for messages or media: In Discord it is ||secret||\n\nI think this could be done using attachments: `\"The secret answer is ![](cid:2).\"`, where attachment 2 is markdown.\n\n> No built-in interactive elements like polls.\n\nThis could be solved in a similar way, but with a new content type for polls.\n\n> No smart timestamps that respect timezones (see https://discord.com/developers/docs/reference#message-formatting-timestamp-styles )\n\nPerhaps this can be implemented using a new URI scheme: `\"The global meeting will start in ![](time:2025-02-11T14:30:00Z?display=absolute)\"`",
          "createdAt": "2025-02-11T16:20:26Z",
          "updatedAt": "2025-02-11T16:20:52Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "MIMI WG bug scrub:\n- Rohan: the special syntax we invent here has to be interoperable\n- Polls deserve a special content-type, but not inline in Markdown (akin to locations)\n- Timo: We could do this in Markdown\n\nWe will write new mimi-content issues for each of spoilers, polls, timestamps and link them here.\n#42 #43 #44\n",
          "createdAt": "2025-02-12T18:20:57Z",
          "updatedAt": "2025-02-12T18:33:20Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOJiBc4M6b9Wrj",
      "title": "Allow users (ex: moderators/administrators) other than the sender to edit/delete messages?",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/24",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "policyknob",
        "has-PR"
      ],
      "body": "timo brought up that moderators or administrators may want/need to ability to delete a message sent by another user, or even edit it. As long as we have policy knobs to prevent the abuse of such a feature, this seems reasonable.",
      "createdAt": "2024-10-27T12:07:25Z",
      "updatedAt": "2024-12-18T19:37:44Z",
      "closedAt": "2024-12-18T19:37:44Z",
      "comments": [
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "@raphaelrobert: there should also be guidance on how these kinds of edits/deletes are presented to the user.",
          "createdAt": "2024-12-04T17:51:58Z",
          "updatedAt": "2024-12-04T17:51:58Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Rohan to change the document to specify how authorization of edits/deletes should work. Mention UI issues \r\n",
          "createdAt": "2024-12-04T17:52:04Z",
          "updatedAt": "2024-12-04T17:52:04Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed. Policy Knob tracked in MIMI room policy issue [#1](https://github.com/ietf-wg-mimi/mimi-room-policy/issues/1)",
          "createdAt": "2024-12-18T19:37:44Z",
          "updatedAt": "2024-12-18T19:37:44Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOJiBc4M6b9YEU",
      "title": "manipulating topicId post facto",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/25",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "policyknob"
      ],
      "body": "\r\n\r\nFrom timo:\r\n\r\n**Example 1**\r\n1. Alice and Bob are regular users in a game development room.\r\n2. Alice wants to throw an idea into the room, but does not think it's worth a new topic: \"What about dragons?\"\r\n3. Bob has a lot of thoughts on the idea and wants to discuss it in detail.\r\n\r\nHe should be able to send a reply to Alice's message containing a new topicId.\r\n\r\n**Example 2**\r\nHere is another example for moderators moving messages to a different topic:\r\n\r\n1. Alice is moderator in a causal room with 100 users, Bob is a regular user.\r\n2. Alice created a \"memes\" topic where funny pictures can be shared without interrupting the discussion in the main room.\r\n3. Bob is not aware of the topic and simply sends these pictures into the main room.\r\n\r\nAlice should be allowed to send edits to the messages to move them into the \"memes\" topic.\r\nNote: Depending on the room policy, moderators may be allowed to move messages to a topic, but not edit the content of the message",
      "createdAt": "2024-10-27T12:19:25Z",
      "updatedAt": "2024-12-18T19:37:57Z",
      "closedAt": "2024-12-18T19:37:57Z",
      "comments": [
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "An alternative to allowing others to add a `topicId` to existing messages would be to have an implicit nameless `topicId` based on the message's `messageId`.\r\n\r\nThis would mean that every message has a `topicId`, for one of the following reason:\r\n- First message in a thread with explicit named `topicId` (like in Zulip)\r\n- Out-of-thread message = first message in a thread with implicit nameless `topicId` (like in Slack)\r\n- Follow-up message in a thread explicitly using the `topicId` of the first message in the thread.",
          "createdAt": "2024-11-07T13:05:48Z",
          "updatedAt": "2024-11-07T13:10:43Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "Distinct from #24, but similar policy considerations apply.",
          "createdAt": "2024-12-04T17:53:22Z",
          "updatedAt": "2024-12-04T17:53:22Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed. Policy Knob tracked in MIMI room policy issue [#1](https://github.com/ietf-wg-mimi/mimi-room-policy/issues/1)",
          "createdAt": "2024-12-18T19:37:57Z",
          "updatedAt": "2024-12-18T19:37:57Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOJiBc4M6b9Yp_",
      "title": "Is more guidance needed on the message delivery statuses?",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/26",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "Section 5.12 should be a top-level section as it is not really part of Examples.\r\n\r\nThe section may also need to provide more guidance on the various message delivery statuses and when to use them",
      "createdAt": "2024-10-27T12:25:16Z",
      "updatedAt": "2025-02-28T21:48:57Z",
      "closedAt": "2025-02-28T21:48:57Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "added a section in commit [1822201](https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/51/commits/18222017dd60d05e0c89c0ed46951a5e0d984662) of #51 ",
          "createdAt": "2025-02-27T05:55:30Z",
          "updatedAt": "2025-02-27T05:55:30Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOJiBc4M6dSYsZ",
      "title": "If Hub accepted timestamp in MIMI protocol is mandatory can we get rid of lastSeen?",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/27",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "",
      "createdAt": "2024-11-06T18:02:21Z",
      "updatedAt": "2025-02-12T18:02:01Z",
      "closedAt": "2025-02-12T18:01:58Z",
      "comments": [
        {
          "author": "turt2live",
          "authorAssociation": "NONE",
          "body": "isn't `lastSeen` for user delivery rather than server delivery?",
          "createdAt": "2024-11-06T20:38:25Z",
          "updatedAt": "2024-11-06T20:38:25Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "lastSeen is a sender provided indicator of message order. \r\n\r\nhub acceptance time is a Hub provided indicator of message order. The franking mechanism now requires the hub acceptance time be delivered to a follower client in order to work. \r\n\r\nIf the follower providers modifies the timestamp, the message will be rejected because the franking context is incorrect. The follower cannot change the franking context to match because the franking context uses a key shared only with the members and the hub.\r\n\r\nSo we are left with four cases:\r\n- honest sender, honest hub\r\n- honest sender, malicious hub\r\n- malicious sender, honest hub\r\n- malicious sender, malicious hub\r\n\r\nThere is nothing we can do about the last case. The \"interesting\" cases are honest sender/malicious hub, and malicious sender/honest hub.\r\n\r\nAn honest sender can correctly set lastSeen, but if it just joined it may not have the messageId of a previous message. Once a sender has included a messageId in one of its messages, it can't appear any later in the sequence from that sender, but other sender could show the same message as seen much later in the sequence. A receiver with a maliciously early hub time and a lastSeen from a single honest sender, can't correct the problem. A receiver with a maliciously late hub time and a lastSeen from an honest sender can detect a problem.\r\n\r\nA malicious sender can't guess a message Id to include it in lastSeen before it was seen, but it can include a message Id much later in the process. A receiver has no way to determine whether to trust the sender or the hub in this case.  ",
          "createdAt": "2024-11-07T08:52:21Z",
          "updatedAt": "2024-11-07T08:52:21Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert says that message reordering or dropped messages by the hub might be better signaled/prevented at the MLS layer (ex: using AppAck)",
          "createdAt": "2024-12-04T18:06:52Z",
          "updatedAt": "2024-12-04T18:07:12Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to the [MIMI Threat Model Issue](https://github.com/ietf-wg-mimi/mimi-protocol/issues/93)",
          "createdAt": "2024-12-04T18:10:18Z",
          "updatedAt": "2024-12-04T18:10:18Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "@kkohbrok to see if MLS has ideas here, or wants to address this at that layer.",
          "createdAt": "2024-12-04T18:12:29Z",
          "updatedAt": "2024-12-04T18:12:29Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "NONE",
          "body": "Let me try to list the individual concerns here.\r\n\r\nI believe at a baseline, we have the agreement that we want all clients to agree on some linear sequence of (application/content) messages in a room. Hub timestamps are authoritative here: Order of message arrival at the hub dictates the sequence of messages that apps SHOULD display for the user. MIMI as a protocol can only make suggestions as to the order in which messages are displayed by the actual client implementation.\r\n\r\nHowever, in the reality of our distributed system, message order is more like a directed tree that depends on which messages a sender has seen at the time a message is sent (vs. the messages that may have already reached the hub, but not the sender).\r\n\r\nBefore we discuss security implications of lastSeen, maybe we should first consider whether we actually want clients to provider more information on which messages they have seen at the time of sending. If there is a critical dependency (\"Do you want ice cream?\", \"Do you want to kill the president?\", \"Yes\"), then users already have \"replyTo\" to work with. If we add more information, that just muddies the water in terms of what clients should actually display to the user.\r\n\r\nIf we want to have the hub as central authority w.r.t. message ordering, there is not much we can do to stop it from back-dating messages. We can, however, include a mechanism that ensures that users agree on the timestamps provided by the hub. I agree with @raphaelrobert that MLS is the right layer to do that. I don't think AppAck quite does the job, though, because it doesn't speak to the odering of messages (or indeed the content).",
          "createdAt": "2024-12-05T08:20:41Z",
          "updatedAt": "2024-12-05T08:20:41Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I want to add one more point about the Hub timestamp. When *sending* a\r\nmessage, the Hub's successful response contains the timestamp. If franking\r\nis enabled, the Hub also includes the server frank which covers that\r\ntimestamp. This substantially constrains the ways the Hub can manipulate\r\ntimestamps undetected.\r\n\r\nthanks,\r\n-rohan\r\n\r\nOn Thu, Dec 5, 2024, 00:21 Konrad Kohbrok ***@***.***> wrote:\r\n\r\n> Let me try to list the individual concerns here.\r\n>\r\n> I believe at a baseline, we have the agreement that we want all clients to\r\n> agree on some linear sequence of (application/content) messages in a room.\r\n> Hub timestamps are authoritative here: Order of message arrival at the hub\r\n> dictates the sequence of messages that apps SHOULD display for the user.\r\n> MIMI as a protocol can only make suggestions as to the order in which\r\n> messages are displayed by the actual client implementation.\r\n>\r\n> However, in the reality of our distributed system, message order is more\r\n> like a directed tree that depends on which messages a sender has seen at\r\n> the time a message is sent (vs. the messages that may have already reached\r\n> the hub, but not the sender).\r\n>\r\n> Before we discuss security implications of lastSeen, maybe we should first\r\n> consider whether we actually want clients to provider more information on\r\n> which messages they have seen at the time of sending. If there is a\r\n> critical dependency (\"Do you want ice cream?\", \"Do you want to kill the\r\n> president?\", \"Yes\"), then users already have \"replyTo\" to work with. If we\r\n> add more information, that just muddies the water in terms of what clients\r\n> should actually display to the user.\r\n>\r\n> If we want to have the hub as central authority w.r.t. message ordering,\r\n> there is not much we can do to stop it from back-dating messages. We can,\r\n> however, include a mechanism that ensures that users agree on the\r\n> timestamps provided by the hub. I agree with @raphaelrobert\r\n> <https://github.com/raphaelrobert> that MLS is the right layer to do\r\n> that. I don't think AppAck quite does the job, though, because it doesn't\r\n> speak to the odering of messages (or indeed the content).\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/27#issuecomment-2519563769>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AADSQPQKBQS5MZNP4Q6IVSL2EAEG7AVCNFSM6AAAAABRJNDAPGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDKMJZGU3DGNZWHE>\r\n> .\r\n> You are receiving this because you authored the thread.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2024-12-05T17:33:58Z",
          "updatedAt": "2024-12-05T17:33:58Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that lastSeen is too complicated. If we want prevent the hub from changing timestamps, we could allow clients to add a timestamp to the content when sending the message. Other clients can show a warning if the the hub and client timestamps differ by more than a few seconds.",
          "createdAt": "2024-12-17T09:44:13Z",
          "updatedAt": "2024-12-17T09:44:13Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed after unanimous feedback. Closing",
          "createdAt": "2025-02-12T18:01:58Z",
          "updatedAt": "2025-02-12T18:01:58Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOJiBc4M6daSz-",
      "title": "Sender timestamp in delivery reports",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/28",
      "state": "CLOSED",
      "author": "mar-v-in",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "Regular messages don't have a sender timestamp (but rather the `lastSeen` that is up for removal via #27) and rely on the hub received timestamp instead. However, delivery reports currently do have a sender timestamp. As the hub will tag delivery reports the same way as regular messages (because it doesn't even know if it's a regular message or delivery report), it only makes sense to be consistent with the two.\r\n\r\nThat said, I do see potentially valid usecases for having a sender timestamp, knowing that it can be spoofed: When sending a message on a mobile device with spotty connectivity, the sending client might be unable to deliver the message to the server when the user intends it. Thus indicating a desired sending time might still be beneficial. To avoid confusion, it likely should not be used for message ordering, but could be displayed with a message if there was no room activity between sender timestamp and hub timestamp or could be used just to indicate that the message was seemingly delivered out of order or with significant delay.",
      "createdAt": "2024-11-07T12:43:42Z",
      "updatedAt": "2025-02-28T21:48:46Z",
      "closedAt": "2025-02-28T21:48:46Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to same set of gnarly issues as #27 ",
          "createdAt": "2024-12-04T18:14:17Z",
          "updatedAt": "2024-12-04T18:14:17Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "MIMI WG bug scrub: the timestamp here needs to be consistent with what we choose in #13",
          "createdAt": "2025-02-12T18:05:37Z",
          "updatedAt": "2025-02-12T18:05:37Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking back over the issue, I think I will remove the timestamp, since consistently the (honest) hub accepted time will be the soonest a client knows that a message could be read/delivered. The hub is going to include this time no matter what type of content. The problem of detecting a hub that is delayed or messages needs to be solved another way and there are some proposals similar to AppAck likely to be forthcoming soon.",
          "createdAt": "2025-02-27T05:13:59Z",
          "updatedAt": "2025-02-27T05:13:59Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #51 ",
          "createdAt": "2025-02-27T05:24:42Z",
          "updatedAt": "2025-02-27T05:24:42Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOJiBc4M6dara2",
      "title": "Rationale and problems for additional hash in InReplyTo",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/29",
      "state": "CLOSED",
      "author": "mar-v-in",
      "authorAssociation": "NONE",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "What is the rationale of having both the `messageId` (which is the hash over the encrypted message) and a hash over the unencrypted message in the reply to?\r\n\r\nAs it is currently states, the hash is algorithm agnostic (has `hashAlg`). Which hash algorithms are allowed and how do clients discover which algorithm to use?\r\n\r\nAdditionally, the hash algorithm agnosticism implies that clients need to keep a copy of the unencrypted message content to be able to compute the hash to be able to compare (or pre-compute all possible hash algorithms). Most clients naturally don't want to keep such a copy (as they will extract the relevant message content into their own data structure and then abandon the raw unencrypted message content bytes) and pre-computing multiple possible hashes for every message (even those that never receive a reply) seems wasteful on resources. Additionally, keeping a copy of the message content would potentially be in conflict with message expiry.",
      "createdAt": "2024-11-07T13:20:31Z",
      "updatedAt": "2025-02-26T19:03:21Z",
      "closedAt": "2025-02-26T19:03:20Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok  proposed hashing the plaintext with a sender-provided salt (in the message), and including that in InReplyTo.\r\n\r\nNote we already have a client franking secret we could use for this.",
          "createdAt": "2024-12-04T18:27:40Z",
          "updatedAt": "2024-12-04T18:27:40Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "NONE",
          "body": "The attack we're trying to defend against here assumes some sort of history sharing, where Alice joins a room and gets a set of past messages from Bob. Now Charlie sends a reply to one of those messages. The security property is that we want Alice to be able to verify which message (and specifically which message content) Charlie is replying to without having to trust Bob.\r\n\r\nIncluding a hash over the original (replied-to) message would provide that security property but would also break forward secrecy: If there is no such history sharing mechanism, Alice could use the hash in the reply-to to learn the message originally sent before she joined the room.\r\n\r\nMy proposal to provide the desired security property without breaking forward secrecy is as Rohan already sketched: With each message, the sender includes a nonce with sufficient entropy. When sharing history, these nonces must be shared alongside the respective messages. In the reply-to we can now include a hash over the unencrypted content and the nonce. Functionality-wise in the first example above (where Bob shared the history with Alice), Alice could now verify that hash based on the messages and nonces she got from Bob. Security-wise we get both properties we need:\r\n- 2nd pre-image resistance of the hash function should prevent Bob from being able to craft a message that matches the hash of another message.\r\n- If Alice doesn't have the original message (and the nonce to go with it), the entropy in the nonce (and the pre-image resistance of the hash function) should prevent Alice from computing the content of the original message.",
          "createdAt": "2024-12-04T18:49:56Z",
          "updatedAt": "2024-12-04T18:49:56Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "Thanks @kkohbrok for the detailed explanation.\r\n\r\nThe issue I see with your sketched history sharing:\r\n- How does Alice learn and verify the original sender of past messages forwarded by Bob?\r\n- How does Alice learn and verify that the set of past messages forwarded by Bob is complete and/or does not include messages that have not been part of the original conversation history?\r\n- How does Alice learn and verify timestamps of the past messages forwarded by Bob?\r\n\r\nThe plaintext message content (at least as of last time I checked) does not include the sender id. Bob thus doesn't need to find a 2nd preimage to the hash to craft new messages that look like they've been replied to, he can just use the original and manipulate authorship.\r\n\r\nTo sketch an attack scenario:\r\n1. Bob, Charlie and David in the room:\r\n2. David: \"Can I get access to resource X?\" with nonce Y and hash Z\r\n3. Alice joins room\r\n4. Bob forwards messages, but replaces David's message with a message that looks as if it was sent by Bob with same content and nonce Y as David's message and thus same hash Z\r\n5. Charlie: \"[reply to hash Z] Sure. Alice, could you go ahead and grant him access.\"\r\n\r\nSo beside the nonce, the hash needs to at least also cover the message sender's id or the InReplyTo needs to reference the sender id.",
          "createdAt": "2024-12-05T10:43:08Z",
          "updatedAt": "2024-12-05T10:44:04Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "Besides all of this, it doesn't explain why we need hash algorithm agility within InReplyTo. If we were to always use the same hash algorithm we also use for the outer MessageId, it would just mean that every message gets a second message id (let's call it MessageContentId) that is generally suitable for your message history sharing usecase, but means significantly reduced complexity on clients (which would just need to compute this second message id once when receiving the message and then have it available for indexing). If we define MessageContentId to be `hash(sender id || mimiContent || nonce)` it can effectively replace most usecases of MessageId. As the purpose of MessageId within mimi-content is already rather unclear (see #34), we might just want to get rid of it entirely within mimi-content (can still be useful for mimi-protocol). In that case the `messageId` , `hash` and `alg` fields in the InReplyTo could be removed completely and replaced with only a `messageContentId`...\r\n\r\nPS: Whatever we decide to use in InReplyTo should also be used in the delivery reports.",
          "createdAt": "2024-12-05T11:01:12Z",
          "updatedAt": "2024-12-05T11:01:12Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "NONE",
          "body": "Since we don't have a history sharing mechanism in MIM (yet) my main concern was to prevent leaking the replied-to plaintext.\r\n\r\nThat being said your points/questions are all very valid if we indeed want a history sharing mechanism baked into MIMI. The problem is that MLS (as MIMI's crypto-engine) doesn't really provide any of these guarantees (or make them easy to get). My intuition is that all of this is possible, but would require some rather complex additional cryptographic machinery. So before we start adding this complexity, I'd like some buy-in from the WG that we actually want a history sharing mechanism on a MIMI-level. Or at least one that doesn't require Alice to just trust Bob to a large degree.\r\n\r\nIf we do have that buy-in, I'd be happy to help design such a mechanism. Sounds like a fun problem to solve :-)\r\n\r\nMeanwhile I think adding the sender id to the hash is a great idea to at least get some slightly better guarantees without much additional complexity.",
          "createdAt": "2024-12-06T07:34:01Z",
          "updatedAt": "2024-12-06T07:34:01Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "If we don't want a trust-less history sharing, we can get rid of the hash entirely to prevent leaking message content and only use the MessageId, which is known and verifiable to all regular recipients of a message, but completely useless and effectively random to anyone that wasn't in the group at the time. And using the MessageId when sharing history with trusted peers (e.g. multiple devices of the same user) is fine as well, as the MessageId as it was before decrypting can just be appended to each shared plaintext message as long as the original receiving client had it stored (which it needs to anyway to support referencing it).\n\nSo I agree we should first figure out if trust-less history sharing is a desired festure, also noting that adding it likely implies that it will increase the size of every message (at least for the nonce, but likely even more) and complexity for every client, even if it is not used. ",
          "createdAt": "2024-12-06T08:37:19Z",
          "updatedAt": "2024-12-06T08:38:01Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "NONE",
          "body": "I wouldn't call it trust-less but having the hash there gives you at least some degree of security with relatively little overhead. We could still do that if we decide that we don't want a more complex solution.\r\n\r\nI agree that whatever mechanism we come up with will increase the message size, but we could turn it on or off on a per-group basis and leave out the hash (or whatever else) if history sharing is turned off.",
          "createdAt": "2024-12-06T09:02:28Z",
          "updatedAt": "2024-12-06T09:02:28Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "I don't agree. If a malicious history sharer can send an arbitrary message history without the recipient being able to verify any of it, the only thing the hash provides is that if InReplyTo is used, the recipient can learn that they never received a specific message or that it was falsified - and this is only if that message receives a reply. This doesn't make history sharing from users/devices that you don't trust 100% any more reasonable than without it.",
          "createdAt": "2024-12-06T09:18:30Z",
          "updatedAt": "2024-12-06T09:18:30Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "NONE",
          "body": "The mechanism is not to protect the recipient of the history. It's to protect (to a certain degree) the sender of the replyTo who has not decided to trust anyone at this point. When they include the hash, they can at least be certain that recipients can verify what content (and even what sender) they meant to reply to.",
          "createdAt": "2024-12-06T09:45:45Z",
          "updatedAt": "2024-12-06T09:45:45Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "If the sender replies to a specific MessageId (which is the hash of the encrypted content) they can already be certain that the recipient can verify all of this, for as long as the recipient was a member of the group when said message was sent. If there was no history sharing, that's all that's needed, because that's everyone who has the message. Everyone that joined later will only be able to tell \"That's a reply to a message I don't know about\".\n\nSo the only purpose of this is history sharing which we haven't decided to be a thing in MIMI at all. I agree that if we had history sharing, something like this is likely needed, although details probably will be a direct consequence of the history sharing itself and don't need to be defined specifically for InReplyTo either (e.g. if we had history sharing, each message was to likely get an additional ID to the MessageId that is likely is the hash of something that includes the unencrypted message content and some structure of message metadata like sender and hub timestamp). That's what I meant earlier with that we can just have another MessageId that is then also used for delivery reports and probably everywhere else where a reference to a previous message is desired (instead of using the current MessageId). I believe such ID would also be more useful for vcon for example (which effectively is some kind of history sharing). ",
          "createdAt": "2024-12-06T10:16:26Z",
          "updatedAt": "2024-12-06T10:17:44Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we close this as satisfied by #36 ?",
          "createdAt": "2025-02-12T17:56:33Z",
          "updatedAt": "2025-02-12T17:56:33Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "MIMI WG bug scrub:\n- Konrad: this only matters if there is some history syncing mechanism. We should revisit this question if/when we decide to do history syncing.\n- Rohan: some of this is resolved by using the optional franking mechanism\n- Tim to write a new issue on mimi-arch to track the question of whether MIMI wants a history syncing mechanism and link to this issue from there. (https://github.com/ietf-wg-mimi/mimi-arch/issues/19)",
          "createdAt": "2025-02-12T18:10:55Z",
          "updatedAt": "2025-02-12T18:34:46Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Read through the thread. There are some requirement to harvest here at the point that we want a history mechanism, but the mechanism currently in *this* draft seems to solve everybody's concerns. Closing.",
          "createdAt": "2025-02-26T19:03:20Z",
          "updatedAt": "2025-02-26T19:03:20Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOJiBc4M6dbMMr",
      "title": "Reference via RFC2392 URI and disposition inline",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/30",
      "state": "OPEN",
      "author": "mar-v-in",
      "authorAssociation": "NONE",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "In the \"Complicated Nested Example\" `multipart-3`, there is a structure that I simplified (for easier understanding) as follows:\r\n```\r\nrender, id:6, multi, processAll\r\n- render, id:7, single, type:text/html, content:<img src=\"cid:10\" />\r\n- inline, id:10, single, type:image/png\r\n```\r\nThe `inline` part with id 10 is referenced from the html in part with id 7. I guess this is meant to imply that the HTML is rendered and the image is retrieved from the part with id 10. There is no mentioning of how RFC2392 URIs are meant to reference outside this example, so I guess that should be made explicit somewhere.\r\n\r\nAdditionally, the `processAll` is supposed to mean that all parts are processed. If I were to process all those parts individually, I would first render the HTML (including the `<img/>`) and then display the image `inline`, thus the image would show twice.\r\nI guess we should either make explicit that if a part with disposition `inline` is already displayed inline due to its use via RFC2392 it should not be displayed inline on its own, or we create an additional explicit disposition that the part should not be rendered at all except through RFC2392 references.",
      "createdAt": "2024-11-07T14:12:56Z",
      "updatedAt": "2025-02-26T19:05:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we need internal references? Sending a single message can also be written as\r\n```\r\ninline, single, type:image/png\r\n```\r\n\r\nIf there is text above and below the image, it can be represented like this:\r\n```\r\nrender, multi, processAll\r\n- render, single, type:text/markdown, content:Here is my cute dog:\r\n- inline, single, type:image/png\r\n- render, single, type:text/markdown, content:What do you think?\r\n```\r\n\r\nI do not know what \"inline\" implies exactly, but it should probably be \"render\", so that clients render it as\r\n```\r\nHere is my cute dog:\r\n\r\n<image>\r\n\r\nWhat do you think?\r\n```\r\n\r\nInstead of\r\n```\r\nHere is my cute dog: <image> What do you think?\r\n```\r\n\r\nThis works for all media types (like images, code blocks, latex math) across plaintext, markdown and html.\r\nThe disadvantage is that media has to be on the top level and cannot be nested inside a bigger html message. This doesn't work:\r\n```\r\n<ul>\r\n    <li><img src=...></li>\r\n    <li><img src=...></li>\r\n</ul>\r\n```\r\n\r\nIf we want to support this nesting, then we probably need internal ids. Otherwise, we might not.",
          "createdAt": "2024-12-17T10:40:31Z",
          "updatedAt": "2024-12-17T10:40:31Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "In email, people already much more complicated examples than here is my cute dog: <image> What do you think?\r\n\r\nIt would suck if people kept sending emails instead of instant messages because they could do more interesting rendering in a decades older protocol.",
          "createdAt": "2024-12-17T20:56:16Z",
          "updatedAt": "2024-12-17T20:56:16Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "> In the \"Complicated Nested Example\" `multipart-3`, there is a structure that I simplified (for easier understanding) as follows:\r\n> \r\n> ```\r\n> render, id:6, multi, processAll\r\n> - render, id:7, single, type:text/html, content:<img src=\"cid:10\" />\r\n> - inline, id:10, single, type:image/png\r\n> ```\r\n> \r\n> The `inline` part with id 10 is referenced from the html in part with id 7. I guess this is meant to imply that the HTML is rendered and the image is retrieved from the part with id 10. There is no mentioning of how RFC2392 URIs are meant to reference outside this example, so I guess that should be made explicit somewhere.\r\n> \r\n> Additionally, the `processAll` is supposed to mean that all parts are processed. If I were to process all those parts individually, I would first render the HTML (including the `<img/>`) and then display the image `inline`, thus the image would show twice. I guess we should either make explicit that if a part with disposition `inline` is already displayed inline due to its use via RFC2392 it should not be displayed inline on its own, or we create an additional explicit disposition that the part should not be rendered at all except through RFC2392 references.\r\n\r\ninline means that something is rendered in the flow of the message, not separately. The disposition doesn't (and could never) comment on where it is rendered. It is not an attachment and it is not rendered separately (as in the WhatsApp rendering of multiple messages sent at the same time).\r\n\r\nI will endeavor to write more language clarifying this. Please see PR# https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/35/commits/b17c7f322b080769fe4d0b735782e8af50c6c6e7#diff-01e95bf8fde9ad9cdd029b94a2ffd2bdfb1b9f5334f96e922df3fed67383f56eR449-R452 to see if this content ID language is on the right track.",
          "createdAt": "2024-12-17T21:00:23Z",
          "updatedAt": "2024-12-17T21:00:23Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the explanation.\r\n\r\nHere are some edge cases that should probably be clarified. Let's say we want to send a message with an image, like the example above:\r\n```\r\nrender, id:6, multi, processAll\r\n- render, id:7, single, type:text/html, content:<img src=\"cid:10\" />\r\n- inline, id:10, single, type:image/png\r\n```\r\n\r\n- Should clients always prefer internal links over chaining content types?\r\n- What would happen if the processAll was chooseOne instead? Will the image be displayed if the client picks the text/html?\r\n- What if an \"inline\" element is wrapped inside a \"attachment\" container (or any other combination)? Maybe only SingleParts should have dispositions?\r\n- Where should alt text for the image go? Like this in two places?:\r\n\r\n```\r\nrender, id:6, multi, processAll\r\n- render, id:7, single, type:text/html, content:<img src=\"cid:12\" alt=\"Alt text\" />\r\n- inline, id:10, multi, chooseOne\r\n    - inline id:11, single, type:text/plain, content:Alt text\r\n    - inline, id:12, single, type:image/png\r\n```\r\n\r\n\r\nAfter thinking more about it, I think the flexibility of this approach is pretty useful. The result of this issue should probably be an explicit rule like this:\r\n\r\n\"First, determine which parts to handle and which to drop immediately (because of chooseOne and singleUnit). Then, iterate through the elements in the order they are defined and render them, unless a previously rendered part has already referenced it.\"\r\n\r\nWhat do you think?",
          "createdAt": "2024-12-17T23:08:53Z",
          "updatedAt": "2024-12-17T23:08:53Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "I just checked my email clients and I see that if there are attachments referenced from the HTML (as inline image) they're still shown as attachments. Now if I switch between HTML and plain text mode, that affects the message content, such that the plain text  version wouldn't show the image inline, but it does not affect the list of attachments. This sounds very reasonable to me, but it implies that I see weird attachments.\r\n\r\nThe rule: \"render them, unless a previously rendered part has already referenced it\" seems not very flexible to me as it implies a specific ordering. Say I want to send an image with a caption below it:\r\n```\r\nrender, id:1, multi, processAll\r\n- inline, id:2, single, type:image/png\r\n- render id:3, chooseOne\r\n  - render, id:4, single, type:text/html, content:\"<figure><img src=\"cid:2\" /><figcaption>Caption</figcaption></figure>\"\r\n  - render, id:5, single, type:text/plain, content:Caption\r\n```\r\n\r\nAlso, what happens if an attachment is referenced, but in a different way than as img src. For example as an a href or a stylesheet. Or, to make an extreme example, as a JavaScript, that is for obvious reasons not executed. Would it still not be displayed because it is already referenced?\r\n\r\n> It would suck if people kept sending emails instead of instant messages because they could do more interesting rendering in a decades older protocol.\r\n\r\nHere I disagree. Instant Messaging and emails are different types of media. It's totally fine if my instant messages can't do complex HTML rendering. If you look at email clients, all of them very clearly transmit what is part of an email and what is another email, typically with significant borders around them. This is necessary due to the flexibility of email.\r\n\r\nWith instant messengers, some popular clients merge different messages together if they're sent closely after each other, some show bubbles, some don't. The styling of the messages is largely decided by the displaying client, not the message itself. And I think that's good. That's why markdown-style input became popular in instant messaging (instead of HTML which was used in instant messaging in the 2000s), because it removed options and thus allowed for better integrations.\r\n\r\nI don't know any instant messaging platform popular these days that allows for full HTML. Most don't even allow setting a text color. And text-inline images (as in: inside the message body with text to its left and right) is also nothing I've ever seen.\r\n\r\nLet's please not overcomplicate this. If we end up specifying something nobody implements due to its complexity, we haven't won anything. As a personal note from a client developer, even if I was to implement HTML (which I still consider a better transport format than the markdown that is currently mandatory), I will probably not support inline images inside HTML and only have some minimal HTML parsing to extract some common markups, but will ignore any more complex structures. This is because I have to somehow fed this into the renderer of the toolkit I'm using and because they rightfully decided to not reimplement a full HTML renderer, they just can't do everything HTML could do (text rendering is already complex enough).",
          "createdAt": "2024-12-18T08:16:28Z",
          "updatedAt": "2024-12-18T08:16:28Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we support internal references to dropped parts, your example above can be written like this:\r\n```\r\nrender, id:1, multi, chooseOne\r\n- render, id:2, single, type:text/html, content:\"<figure><img src=\"cid:4\" /><figcaption>Caption</figcaption></figure>\"\r\n- render id:3, multi, processAll\r\n    - inline, id:4, single, type:image/png\r\n    - render, id:5, single, type:text/plain, content:Caption\r\n```\r\n\r\nBut you make some good arguments, leading back to the question \"Do we want to support nesting?\".\r\n",
          "createdAt": "2024-12-18T08:50:45Z",
          "updatedAt": "2024-12-18T08:50:45Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Explanation of how to do this added in PR #35 . Leaving issue open in case we decide to use a simpler formulation than NestedPart for multipart content.",
          "createdAt": "2024-12-18T19:41:16Z",
          "updatedAt": "2024-12-18T19:41:16Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I fear that using a too flexible model can lead to providers encoding their message differently and being unable to interoperate fully. We should focus on instant messaging. But I can also understand there could be special cases for very flexible messages.\n\nCan we agree on one simple format that must be supported by all mimi clients and then allow additional formats using client capability negotiation?\n\nFor example the mimi-content struct could look like this:\n```\nmimiContent = [\n  salt: bstr .size 32,\n  replaces: null / MessageId,\n  topicId: bstr,\n  expires: uint .size 4,\n  inReplyTo: null / InReplyTo,\n  lastSeen: [* MessageId],\n  extensions: {* name => value },\n  contentType: tstr,         ; This field is new\n  nestedPart: bstr           ; Format depends on contentType\n]\n```\n\nAnd all clients must support the new contentType application/mimi-markdown. This has a limited amount of nesting.\n```\nMimiMarkdown = [\n    markdownChooseOne: [* LanguageMarkdown],\n    attachments: [* Attachment]  ; The list of attachments, each with multiple variants.\n]\n\nLanguageMarkdown = [\n    language: tstr,\n    markdown: tstr,\n]\n\nAttachment = [\n    chooseOne: [* LanguageAndExternalPart]\n]\n\nLanguageAndExternalPart = [\n    language: tstr,\n    contentType: tstr,\n    url: uri,\n    [...]\n    filename: tstr\n]\n```\n\nAnother contentType clients must support could be application/mimi-reaction that contains just a single emoji character or a reference to a custom reaction defined in the room policy.\n\nIn the future, if someone wants to make use of more complicated nesting in html, they can define a new content type for it and negotiate the capabilities so that all clients in the room understand it.",
          "createdAt": "2025-02-11T14:23:56Z",
          "updatedAt": "2025-02-11T14:23:56Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Rohan to add this text from Timo to the document:\n\"First, determine which parts to handle and which to drop immediately (because of chooseOne and singleUnit). Then, iterate through the elements in the order they are defined and render them, unless a previously rendered part has already referenced it.\"",
          "createdAt": "2025-02-12T18:15:11Z",
          "updatedAt": "2025-02-12T18:15:11Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "MIMI WG bug scrub: we need one more tweak to the text per [Timo's 12/17/2024 comment](https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/30#issuecomment-2549847624)",
          "createdAt": "2025-02-12T18:15:19Z",
          "updatedAt": "2025-02-12T18:15:19Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Covered by #48 \n\nAlternative to much of the multipart content described in #49",
          "createdAt": "2025-02-26T19:05:48Z",
          "updatedAt": "2025-02-26T19:05:48Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOJiBc4M6dbiQI",
      "title": "Get rid of partIndex or make it optional",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/31",
      "state": "CLOSED",
      "author": "mar-v-in",
      "authorAssociation": "NONE",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed"
      ],
      "body": "Currently, it is strictly required to assign a `partIndex` to every part in depth-first counting. This makes it superfluous to transfer it as the `partIndex` can always be derived on the recipient side (and the recipient is also expected to verify the `partIndex` and discard messages with invalid assignments).\r\n\r\nAdditionally, the `partIndex` makes things rather complex on the sender side as the index of a specific part is only known after the final message structure is constructed. Usually the message payload is available first (e.g. the user writes a message in the chat client and attaches files or adds them inline) and the structure is derived thereof. The current design requires the client to first build the part structure and then adjust the user-created HTML to correctly reference the respective part.\r\n\r\nI thus suggest one of the following:\r\n- Get rid of the explicit `partIndex` in the transferred data and expect the recipient to assign `partIndex` when receiving the message\r\n- Make `partIndex` optional and allow it to be non-continuous. Sending clients would only put `partIndex` to parts that they seem sensible to reference in the future.\r\n- A combination of the two: Get rid of explicit `partIndex` but allow putting an optional explicit textual content-id. Allow senders/recipients to either reference the part by the implicit `partIndex` or the explicit content-id. This makes it possible to reference every part of a generates message but solves the issues with complexity during message generation.",
      "createdAt": "2024-11-07T14:41:59Z",
      "updatedAt": "2024-12-18T19:40:07Z",
      "closedAt": "2024-12-18T19:40:06Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Required in order to address to inline content as in #30",
          "createdAt": "2024-12-04T18:34:23Z",
          "updatedAt": "2024-12-04T18:35:30Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Take to the mailing list after addressing #30 ",
          "createdAt": "2024-12-04T18:39:31Z",
          "updatedAt": "2024-12-04T18:39:31Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2024-12-18T19:40:06Z",
          "updatedAt": "2024-12-18T19:40:06Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "I_kwDOJiBc4M6e6VUh",
      "title": "Move FrankingAssertion from mimi-protocol into mimi-content",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/32",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "Corresponds to MIMI protocol issue https://github.com/ietf-wg-mimi/mimi-protocol/issues/91",
      "createdAt": "2024-11-17T16:30:54Z",
      "updatedAt": "2025-02-26T19:06:29Z",
      "closedAt": "2025-02-26T19:06:28Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "the sender URI and room URI are now referenced as MIMI extensions in the Message ID calculation as of PR #36   , and in the examples in PR #46 . I still need a PR to update the IANA considerations to register extensions.",
          "createdAt": "2025-02-24T19:59:31Z",
          "updatedAt": "2025-02-24T19:59:31Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. covered by #47 ",
          "createdAt": "2025-02-26T19:06:28Z",
          "updatedAt": "2025-02-26T19:06:28Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOJiBc4M6e6VZv",
      "title": "Create IANA registry for MIMI content extension map keys",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/33",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed"
      ],
      "body": "Highly dependent on the new AppSync draft and its use of Component IDs:\r\nhttps://github.com/bifurcation/mls-appsync/blob/app-api/draft-barnes-mls-appsync.md",
      "createdAt": "2024-11-17T16:31:36Z",
      "updatedAt": "2024-12-18T19:33:59Z",
      "closedAt": "2024-12-18T19:33:59Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed",
          "createdAt": "2024-12-18T19:33:59Z",
          "updatedAt": "2024-12-18T19:33:59Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "I_kwDOJiBc4M6hH_69",
      "title": "message IDs can't be calculated for messages in history",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/34",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "message IDs are currently calculated as the hash of the ciphertext of the message. Since the ciphertext is usually deleted after decryption and isn't useful without the relevant keying material, historical messages (for example decrypted on a previous device) can't be used to calculate their own message ID.",
      "createdAt": "2024-11-28T20:46:13Z",
      "updatedAt": "2025-02-12T17:43:36Z",
      "closedAt": "2025-02-12T17:43:35Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #29",
          "createdAt": "2024-12-04T18:16:48Z",
          "updatedAt": "2024-12-04T18:17:02Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Also Related to the https://github.com/ietf-wg-mimi/mimi-protocol/issues/93",
          "createdAt": "2024-12-04T18:30:34Z",
          "updatedAt": "2024-12-04T18:31:22Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I shared a new proposed construction of MIMI message ID on the mailing list:\r\n\r\n------\r\n# Current state of MIMI Message IDs\r\n\r\nMIMI content format uses message IDs extensively. They are used to refer to replaced (edited and deleted) messages, and InReplyTo (for replies and reactions). They are used in read-receipts/delivery notifications.\r\n\r\nCurrently they are constructed from the first 32-octets of the hash of the ciphertext (using the current ciphersuite's hash). This has a number of problems, one of which is that there is no way to generate the message ID from the message once it has been decrypted. Since this is often done at a different layer of the application stack and MLS tries to aggressively delete unused keying material, this approach has always felt tenuous to me.\r\n\r\n# Proposal\r\n\r\nI'm going to go ahead and propose a solution now that I think has the same advantages as the current approach and several new advantages.\r\n\r\nsalt = a 16-octet per-message random salt. This could be optionally derived from MLS\r\nsender = the senders MIMI URI\r\nroom = the room MIMI URI\r\nmessage = the entire MIMI content message\r\nhashalg = the 1 octet hash function ID from the IANA hash algorithm registry here: https://www.iana.org/assignments/named-information/named-information.xhtml#hash-alg (the default would be SHA256)\r\nh = hash( salt || sender || room || message)\r\nmessageID = left( hashalg || h, 32)\r\n\r\nI think we should further specify that we should use SHA256 as the hash for message ID generation until we have some concrete reason to deprecate it (practical birthday attack discovered, etc). The first octet would allow hash agility in the event we find such a practical attack (as with MD5).\r\n\r\nNote that while intermediaries could no longer calculate the message ID in the proposed approach, there is exactly nowhere in the MIMI protocol where a provider needs a message ID, so this is irrelevant. A provider is still free to generate a \"provider message ID\" however it likes, including using a hash of the ciphertext.\r\n\r\nSame as before:\r\n- seeing the message ID still does not leak the content of the message (requires a birthday attack on SHA256)\r\n- attacker can't replace a specific message with a new one with different context (requires a birthday attack on SHA256)\r\n\r\nAdvantages:\r\n- ciphertext no longer needed to calculate the message ID\r\n- the same information not in the message (salt, sender, room) is currently used for the franking mechanism as in the proposed message ID calculation.  (Note that the franking_tag is an HMAC using a different construction so it does not leak information when using this message ID scheme.)\r\n- even if a room ReInit its MLS group to use a new ciphersuite, the members can still calculate the hash.\r\n- InReplyTo now only needs a single message ID (since it IS a content hash)\r\n- further advantages if new joiners have the history of a room. even if a malicious member provided tampered history to a new joiner, they would not be able to convince the new joiner that a tampered message (or even a legitimate message from another room or sender) was the subject of a replacement or reply/reaction.\r\n\r\n# History\r\n\r\nMessage history is a major and desirable feature in many messaging systems. It could be message history from an old client being used on a newer device (upgrading phones), or history shared in a room with new joiners (either explicitly or automatically).\r\n\r\nAs discussed in the interim, one of the problems with history is that we cannot use MLS signatures to prove authenticity of messages sent, because signatures cover the entire GroupContext (GC) for the epoch in which a message was sent. The GC might include sensitive information and it can be very big. It is certainly not something we can or want to practically store in the history, per-group, per-epoch. The signature also would not cover the message ID.\r\n\r\nHowever a new joiner gets history of a room, it is encouraging that the proposed message ID construction is still tamper resistant. In other words, while a separate mechanism is required to provide full integrity and authenticity of historical messages, this message ID scheme assured that the original message referenced in a reply/reaction/edit/delete could not be tampered with without it appearing as a different message ID altogether. ",
          "createdAt": "2024-12-09T19:14:54Z",
          "updatedAt": "2024-12-09T19:14:54Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged #36 \nClosing",
          "createdAt": "2025-02-12T17:43:35Z",
          "updatedAt": "2025-02-12T17:43:35Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "I_kwDOJiBc4M6jnutY",
      "title": "Content-type mismatch between notation and cbor",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/38",
      "state": "CLOSED",
      "author": "timokoesters",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "rohanmahy"
      ],
      "labels": [
        "WG reviewed",
        "has-PR"
      ],
      "body": "This issue is present in many of the examples\r\n\r\nhttps://github.com/ietf-wg-mimi/draft-ietf-mimi-content/blob/9b8a6a32a9d0a05169742478de1a92759338372c/examples/original.edn#L13\r\n\r\nhttps://github.com/ietf-wg-mimi/draft-ietf-mimi-content/blob/9b8a6a32a9d0a05169742478de1a92759338372c/draft-ietf-mimi-content.md?plain=1#L589\r\n\r\nAnd another one is in section 5.6 Delete, where it says uses disposition=Render, but the cbor uses value `2`, which is a reaction.",
      "createdAt": "2024-12-17T14:32:15Z",
      "updatedAt": "2025-02-26T19:06:58Z",
      "closedAt": "2025-02-26T19:06:57Z",
      "comments": [
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another mismatch is in the last_seen entry in Delete and Unlike:\r\n\r\n89d3472622a40d6ceeb27c42490fdc64c0e9c20c598f9d7c8e81640dae8db0fb\r\n!=\r\n89d3472622a4d9de526742bcd00b09dc78fa4edceaf2720e17b730c6dfba8be4\r\n",
          "createdAt": "2024-12-17T14:35:23Z",
          "updatedAt": "2024-12-17T14:35:23Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And another typo is in the partIndex here:\r\n\r\nhttps://github.com/ietf-wg-mimi/draft-ietf-mimi-content/blob/9b8a6a32a9d0a05169742478de1a92759338372c/examples/multipart-1.edn#L26\r\n\r\nI can clean them up in a PR if you want, but I should probably wait for !35 and !37 to avoid conflicts",
          "createdAt": "2024-12-17T14:45:29Z",
          "updatedAt": "2024-12-17T14:54:32Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @timokoesters, I'll rebuild the examples from scratch once we decide if we merge the latest PRs.",
          "createdAt": "2024-12-17T20:47:21Z",
          "updatedAt": "2024-12-17T20:47:21Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I think these are all addressed now in #46 ",
          "createdAt": "2025-02-24T19:30:14Z",
          "updatedAt": "2025-02-24T19:30:14Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #46 . Closing",
          "createdAt": "2025-02-26T19:06:57Z",
          "updatedAt": "2025-02-26T19:06:57Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOJiBc4M6j0Kod",
      "title": "Should Expiration types be extensible beyond absolute and relative",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/39",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wontfix",
        "WG reviewed"
      ],
      "body": "",
      "createdAt": "2024-12-18T17:17:35Z",
      "updatedAt": "2025-03-19T07:35:42Z",
      "closedAt": "2025-03-19T07:35:41Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed at IETF 122. Closing with won't fix. Created #53 to make sure it is clear this could be done later as an extensions",
          "createdAt": "2025-03-19T07:35:41Z",
          "updatedAt": "2025-03-19T07:35:41Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOJiBc4M6p0RIR",
      "title": "No spoiler syntax for messages or media",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/42",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "[Unresolved issue from #23](https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/23#issuecomment-2651317240)\n\n> No spoiler syntax for messages or media: In Discord it is ||secret||\n> > I think this could be done using attachments: \"The secret answer is ![](cid:2).\", where attachment 2 is markdown.",
      "createdAt": "2025-02-12T18:31:23Z",
      "updatedAt": "2025-03-19T07:36:41Z",
      "closedAt": "2025-03-19T07:35:11Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed at IETF 122. Closing with won't fix. Created #53 to make sure it is clear this could be done later as an extensions",
          "createdAt": "2025-03-19T07:35:11Z",
          "updatedAt": "2025-03-19T07:35:11Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "I_kwDOJiBc4M6p0Rz-",
      "title": "No built-in interactive elements like polls",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/43",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "Unresolved issue from #23 \n\n> No built-in interactive elements like polls.\n> > This could be solved in a similar way, but with a new content type for polls.",
      "createdAt": "2025-02-12T18:32:46Z",
      "updatedAt": "2025-03-19T07:36:24Z",
      "closedAt": "2025-03-19T07:34:58Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed at IETF 122. Closing with won't fix. Created #53 to make sure it is clear this could be done later as an extensions",
          "createdAt": "2025-03-19T07:34:58Z",
          "updatedAt": "2025-03-19T07:34:58Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "I_kwDOJiBc4M6p0SCr",
      "title": "No smart timestamps that respect timezones",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/44",
      "state": "CLOSED",
      "author": "tgeoghegan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "Unresolved issue from #23 \n\n> No smart timestamps that respect timezones (see https://discord.com/developers/docs/reference#message-formatting-timestamp-styles )\n> >Perhaps this can be implemented using a new URI scheme: \"The global meeting will start in ![](time:2025-02-11T14:30:00Z?display=absolute)\"",
      "createdAt": "2025-02-12T18:33:15Z",
      "updatedAt": "2025-03-19T07:36:05Z",
      "closedAt": "2025-03-19T07:34:45Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed at IETF 122. Closing with won't fix. Created #53 to make sure it is clear this could be done later as an extensions",
          "createdAt": "2025-03-19T07:34:45Z",
          "updatedAt": "2025-03-19T07:34:45Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOJiBc4M6q2R1N",
      "title": "Swap order of message ID hash inputs to prevent SHA-256 length extension attack",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/45",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-PR"
      ],
      "body": "CURRENTLY:\n`hash_output = hash( senderUri || roomUri || message )`\n\nBETTER:\n`hash_output = hash( message || senderUri || roomUri )`",
      "createdAt": "2025-02-20T14:38:32Z",
      "updatedAt": "2025-02-26T19:07:45Z",
      "closedAt": "2025-02-26T19:07:44Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #46 . Closing.",
          "createdAt": "2025-02-26T19:07:44Z",
          "updatedAt": "2025-02-26T19:07:44Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOJiBc4M6rbJoU",
      "title": "Add IANA registry for MIMI content extensions",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/47",
      "state": "CLOSED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "has-PR"
      ],
      "body": "",
      "createdAt": "2025-02-24T20:00:17Z",
      "updatedAt": "2025-02-28T21:48:15Z",
      "closedAt": "2025-02-28T21:48:14Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "addressed with #50 ",
          "createdAt": "2025-02-28T21:48:14Z",
          "updatedAt": "2025-02-28T21:48:14Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOJiBc4M6rz2vY",
      "title": "Proposal for simpler content attachments",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/49",
      "state": "OPEN",
      "author": "timokoesters",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I originally proposed this in https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/30#issuecomment-2650974575\n\n# Problems\n\nThe current approach allows for the same message to be encoded in many different ways. Is this complexity really necessary?\nFor example an image with a caption can be:\n\n1.\n```\nrender, id:1, multi, processAll\n- inline, id:2, single, type:image/png\n- render, id:3, single, type:text/markdown, content:\"Caption\"\n```\n2.\n```\nrender, id:1, multi, processAll\n- render, id:2, single, type:text/markdown, content:\"![](cid:3)\\nCaption\"\n- attachment, id:3, single, type:image/png\n```\nLanguage tags can be nested incorrectly and reference each other. How would this render?:\n```\nrender, id:1, multi, chooseOne\n- english, render, id:2, multi, chooseOne\n    - german, render, id:3, single, type:text/markdown, content:\"![](cid:3)\"\n    - french, render, id:4, single, type:text/markdown, content:\"![](cid:5)\"\n- german, render, id:5, multi, chooseOne\n    - english, render, id:6, single, type:text/markdown, content:\"![](cid:2)\"\n    - french, render, id:7, single, type:text/markdown, content:\"![](cid:8)\"\n- french, attachment, id:8, single, type:image/png\n```\n\n# Proposal\n\nI think each message should have one easy to find markdown file as the foundation. Everything else is an attachment that can be referenced by the main markdown file. Here is an example:\n\n```\nmarkdownChooseOne:\n- english: \"Image: ![](cid:1), Video: ![](cid:2)\"\n- german: \"Foto: ![](cid:1), Film: ![](cid:2)\"\n\nattachments:\ncid:1 chooseOne:\n    - english: image\n    - german: image\ncid:2 chooseOne\n    - english: video\n```\n\n# Definitions\n\nThe mimi-content struct could look like this:\n```\nmimiContent = [\n  salt: bstr .size 32,\n  replaces: null / MessageId,\n  topicId: bstr,\n  expires: uint .size 4,\n  inReplyTo: null / InReplyTo,\n  lastSeen: [* MessageId],\n  extensions: {* name => value },\n  contentType: tstr,         ; This field is new\n  nestedPart: bstr           ; Format depends on contentType\n]\n```\n\nAnd all clients must support the new contentType application/mimi-markdown. This has a limited amount of nesting.\n```\nMimiMarkdown = [\n    markdownChooseOne: [* LanguageMarkdown],\n    attachments: [* Attachment]  ; The list of attachments, each with multiple variants.\n]\n\nLanguageMarkdown = [\n    language: tstr,\n    markdown: tstr,\n]\n\nAttachment = [\n    chooseOne: [* LanguageAndExternalPart]\n]\n\nLanguageAndExternalPart = [\n    language: tstr,\n    contentType: tstr,\n    url: uri,\n    [...]\n    filename: tstr\n]\n```\n\nAnother contentType clients must support could be application/mimi-reaction that contains just a single emoji character or a reference to a custom reaction defined in the room policy.\n\nIn the future, if someone wants to make use of more complicated nesting in html, they can define a new content type for it and negotiate the capabilities so that all clients in the room understand it.",
      "createdAt": "2025-02-26T18:41:56Z",
      "updatedAt": "2025-04-01T18:47:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "IMO, mimi-content should require a content system that has reasonable structure for forwards compatibility built in. From how I understood your proposal, it does not allow to upgrade to anything else without breaking compatibility with existing clients and with no means to provide a sensible fallback to them.\n\nTo make an example, let's say I want to send a text message with a word in red letters in it, which markdown does no support, but html does. With your system I can send using a different contentType that supports html payloads, which would result in all recipients that don't support that contentType to discard such message. With the current draft proposal, I can have a chooseOne between markdown and html and have those clients that can't do html display something that's not the same, but close enough for my purpose (e.g. make it italic instead or write out explicitly that this text is in blue or replace the respective part with an inline image that has the text in blue - there's probably a lot of options).\n\nForward compatibility implicitly means we need at least some sort of chooseOne at the root level to pick between different content types. Similarly, and because many existing content types can't do that themselves, it makes sense to have chooseOne for the language. And once you start to have chooseOne, you likely want to add something for files that appear in multiple of the chooseOne paths (like the same image file being referenced in the english and german, html and markdown), so that they don't need to be duplicated.",
          "createdAt": "2025-02-26T20:19:32Z",
          "updatedAt": "2025-02-26T20:19:44Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the response! One could integrate your idea by adding another property to the main documents:\n\n```\ndocumentChooseOne:\n- english markdown: \"Image: ![](cid:1), Video: ![](cid:2)\"\n- german markdown: \"Foto: ![](cid:1), Film: ![](cid:2)\"\n- english html: \"<p>Image: <img src=\"cid:1\" />, Video: <video src=\"cid:2\"></video></p>\"\n- german html: \"<p>Foto: <img src=\"cid:1\" />, Film: <video src=\"cid:2\"></video></p>\"\n\nattachments:\ncid:1 chooseOne:\n    - english: image\n    - german: image\ncid:2 chooseOne\n    - english: video\n```\n\nI think this clear hierarchy makes it easier to parse and understand the message:\n1. The main document is always just one layer of chooseOne\n2. The main documents can reference attachments, but not other main documents\n3. Attachments cannot reference anything\n\nAre there messages we want to send that cannot be represented with this proposal?",
          "createdAt": "2025-02-26T20:44:37Z",
          "updatedAt": "2025-02-26T20:44:37Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "What about a text message with a contact (vCard) attachment that references a profile picture inside it?",
          "createdAt": "2025-02-27T01:34:06Z",
          "updatedAt": "2025-02-27T01:34:06Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "What about files that markdown does not support, let's say a pdf? If the recipient client supports it, it would be nice to be able to signal that I want the pdf to be displayed inline - or not if it is clearly meant as a download (aka I sometimes want disposition hints). Also I might want to send an accompanying text to the pdf (in markdown or html), both above and below the file.",
          "createdAt": "2025-02-27T07:15:48Z",
          "updatedAt": "2025-02-27T07:15:48Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What about a text message with a contact (vCard) attachment that references a profile picture inside it?\n\nThis would require special client handling, because it requires parsing the vcard and replacing the cid reference with something that other programs can understand. Do email clients do this? Alternatively, clients can embed the image inside the vcard as base64.\n\n> What about files that markdown does not support, let's say a pdf\n\nI think we are already breaking the boundaries of markdown, given that the `![]()` syntax is only meant for inline images. I think we should generally allow all types of attachments to be referenced from the markdown. Then your example looks like this:\n\n```\nHere is our homework for today:\n\n![](cid:1)\n\nCan you help me?\n```\n\nIf the client is not able to render the content, it will just show it as an attachment.",
          "createdAt": "2025-02-27T10:02:53Z",
          "updatedAt": "2025-02-27T10:02:53Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At IETF 122 we discussed this issue again and Marvin and Daniel agreed, that the current approach is overcomplicated. I still believe the approach I introduced in this issue will be a sufficient solution. How can we continue?",
          "createdAt": "2025-03-25T13:45:22Z",
          "updatedAt": "2025-03-25T13:45:22Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "Your proposal still ties us to complex rich text formats for simple things like \"sending an message that has a picture and a text\". Also note that as of now, the draft says that \"rendering Markdown as plain text is an acceptable form of support\", specifically so that complex markdown logic is not required to be a mimi-content compliant client.\n\nYour proposal still has no understanding of disposition (mostly: display a file inline vs display it as a download-able item). I don't think the assumption \"if the receiving client can display a file inline, it should do so\" is a good idea in general. Say I send a 2 hour movie file, a podcast, or a bunch of songs: Those are typically not meant for consumption in the chat, but rather outside. I don't want to end up with people using the `application/octet-stream` media type again just to signal that the file should be downloaded.\n\nThe current draft is media type agnostic for inline media, meaning it's possible to send a message using two different media types and allow the receiving client to decide, based on its capabilities, which of the two the download and render. This sounds very useful in a diverse client landscape. Anecdotal from dealing with interoperability of existing messaging system, an example here would be SVG which some clients support for inline display and some don't.\n\nI think, whatever system we have, should be able to directly address attachments, that is independent of the language. External systems, e.g. vCon, likely want to be able identify a specific file and not have the consuming client decide based on the language.\n\nYou initially raised the problem that the \"current approach allows for the same message to be encoded in many different ways\". The currently described GFM-MIMI markdown dialect also has this property, even if it was the only allowed textual content type in mimi-content. Just for inline images, there is the inline notation, the reference notation and the collapsed reference notation. Realistically, if we don't put significant limits on the usefulness of mimi-content, there is no way to prevent this from happening. Also, the two examples you shared initially are not even 100% identical: The first displays two units, one with an image and one with the text \"Caption\", the second displays a single unit, that is a paragraph with an inline image and the text \"Caption\". While they are similar, they are semantically different and may be rendered differently.\n\ntl;dr: While I don't particularly like the current draft approach, it works well, isn't hard to implement, and doesn't impose any significant limitation on us. It may be more complex than strictly necessary, but as I said at IETF, I don't see a reasonable way to make things easier without increasing implementation complexity or significantly limiting the features of mimi-content. In the lack of better alternatives, I'm fine with the current draft approach.",
          "createdAt": "2025-03-25T16:01:10Z",
          "updatedAt": "2025-03-25T16:01:10Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> draft says that \"rendering Markdown as plain text is an acceptable form of support\"\n\nHmm, it's hard to say what acceptable is. The user can still read all text and view the attachments, but has some unintuitive references inside. The current draft with inline references has the same problem.\n\n> mostly: display a file inline vs display it as a download-able item\n\nMy assumption is \"If an attachment is referenced from markdown, display it inline. If an attachment is not referenced, display it as a downloadable item.\"\n\n> it's possible to send a message using two different media types and allow the receiving client to decide\n\nThis would also be possible in my approach the client can pick any element in the Attachment chooseOne list and can decide based on all LanguageAndExternalPart fields, like language, content type, file size, expiry, ...\nWe can also add another field to LanguageAndExternalPart to give more hints on how it should be used (thumbnail or actual image).\n\n> External systems want to be able identify a specific file and not have the consuming client decide based on the language.\n\nI did not know that was a usecase, but we can cover it by extending the reference syntax to `cid:<number>/<variant>`, for example `cid:2/3`. The slash could also be a ':' or '.' .\n\n> current approach allows for the same message to be encoded in many different ways\n\nI think we should try to avoid complexity when we can. The two approaches are very different but have the same purpose. If we allow both encodings, then clients probably also need code to convert between them. I chose the second approach, because it is more powerful. For example clients can put images inside a block quote or show images in a grid using a markdown table.\n\n> Also, the two examples you shared initially are not even 100% identical\n\nAdding another newline should make them semantically equivalent, right? `![](cid:3)\\n\\nCaption`\n\n> While I don't particularly like the current draft approach, it works well, isn't hard to implement, and doesn't impose any significant limitation on us.\n\nIs your implementation public? I'm interested in how you implemented the pickOne selection and what your algorithm would do in my example at the top about \"Language tags can be nested incorrectly and reference each other\".",
          "createdAt": "2025-04-01T07:58:28Z",
          "updatedAt": "2025-04-01T07:58:28Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "> Hmm, it's hard to say what acceptable is. The user can still read all text and view the attachments, but has some unintuitive references inside. The current draft with inline references has the same problem.\n\nWhich is why it's better to avoid inline references from markdown. The current draft provides the tools such that you don't have to do that in most cases.\n\n> My assumption is \"If an attachment is referenced from markdown, display it inline. If an attachment is not referenced, display it as a downloadable item.\"\n\nWhat speaks against a message: \n```\nLook at this file: \n[External part with disposition attachment (e.g. an odt)]\nGreat, isn't it?\n```\nI've seen this in emails, I think Apple Mail and Outlook have sending support for this.\n\n> For example clients can put images inside a block quote or show images in a grid using a markdown table.\n\nNot all clients will (be able to) support this variety of features. Not everyone is using a full HTML renderer to display messages.\n\n> Adding another newline should make them semantically equivalent, right?\n\nThey might render the same, depending on your rendering logic, but they are not semantically the same. The one thing is two parts (which may be rendered separated by a newline), the other is one part that just happens to have newlines/paragraphs in it.\n\n> I'm interested in how you implemented the pickOne selection and what your algorithm would do in my example at the top about \"Language tags can be nested incorrectly and reference each other\".\n\nIn fact, my current implementation just assigns the language tag of a MultiPart to its sub-parts (if they don't specify a language) and ignores disposition on MultiPart entirely. **I believe it might be sensible to just move language/disposition to SinglePart/ExternalPart as they hardly have a meaningful purpose when used on MultiPart or NullPart.**\n\n<details><summary>Algorithm in my implementation</summary>\n<p>\nAt a high level:\n\n- SinglePart/ExternalPart: Assign some preference floating number [0,1]. The actual assigning is application and/or context specific, but likely includes language, content type and other metadata (e.g. on mobile data you might prefer the smaller version of an image file over the larger one if it's not cached yet, but when connected to wifi you prefer the higher resolution). If preference is 0, the part is not rendered.\n- MultiPart chooseOne: The preference is determined by the highest preference of its parts. We render the part with the highest preference (if multiple with the same preference, pick the one with lower id).\n- MultiPart singleUnit: The preference is determined by the lowest preference of its parts. If preference is 0, don't render at all, else render all.\n- MultiPart processAll: The preference is nth-root of all parts preferences multiplied. Even if preference is 0, try render all parts (at least one of the parts in this subtree won't be rendered though).\n\nThis means that (as I said, my algorithm ignores language/disposition on MultiPart) nested `chooseOne`s can effectively be collapsed.\n</p>\n</details> \n\nRegarding the circular references from within the markdown in your example: As using the inline images notation of markdown for anything that's not an image (including videos, fwiw) is not allowed as per the GFM-MIMI specification, the referenced part will not be rendered. So the circular references are actually not relevant.\n\nFor that your example referencing a German thing from a French thing: I think that's perfectly fine, I can send a German image file inside a French text.",
          "createdAt": "2025-04-01T10:48:58Z",
          "updatedAt": "2025-04-01T10:48:58Z"
        },
        {
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Which is why it's better to avoid inline references from markdown.\n\nFor the record, I proposed this at the beginning too, but Rohan was strongly in favor of the internal references: https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/30#issuecomment-2549611695 and I can see the advantages it has.\n\n> What speaks against a message: [...] I've seen this in emails, I think Apple Mail and Outlook have sending support for this.\n\nIf we want this, we can do this by adding the disposition to the externalpart, like you also suggested for the current draft in your bold text.\n\n> Not all clients will (be able to) support this variety of features. Not everyone is using a full HTML renderer to display messages.\n\nI read the RFC draft as GFM-MIMI markdown being the main message format. If we keep it like this, then we should expect that clients could use all features. Note that this is does not require a full html renderer. You can instead parse markdown directly to UI widgets. I have an implementation here:\nFlutter part: https://github.com/phnx-im/infra/blob/fbeaa5e541a7839f9e007618402a4807b7ac2318/app/lib/message_list/message_renderer.dart\nRust part: https://github.com/phnx-im/infra/blob/fbeaa5e541a7839f9e007618402a4807b7ac2318/applogic/src/api/markdown.rs\n\n---\n\nLet's assume we must support these references in gfm-mimi markdown and use them for images, files, conference links etc. and clients must support it to give a good user experience. Would you agree with this assumption my proposal would be good?\n\nOn the other hand, let's assume we do not need internal references and instead compose content using multipart constructions. This means that we cannot interleave markdown blocks and multipart blocks, like a block quote containing images. If we still want it to work like this, then I still think we can make small adjustments to the content format, but can close this issue.\n\nCan we agree that the decision between these two variants is the core of our disagreement? Then we need to find out how we can resolve it.",
          "createdAt": "2025-04-01T12:51:16Z",
          "updatedAt": "2025-04-01T12:51:16Z"
        },
        {
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "body": "> For the record, I proposed this at the beginning too, but Rohan was strongly in favor of the internal references\n\nI meant to avoid it from markdown, given that with the current specification, any processing of markdown is optional, so doing this means to potentially expose the recipient to gibberish markdown things. Avoiding also means that if it's necessary for what you want to express, feel free to do it nonetheless, but then it's best to provide a reasonable `text/plain`-based fallback for those clients that don't support it.\n\n> I read the RFC draft as GFM-MIMI markdown being the main message format.\n\nI read that\n- `text/plain` is required\n- `text/markdown;variant=GFM-MIMI` is required to the extent that the client must render it as if it was `text/plain` if it doesn't know any better. (\"it is acceptable to render the contents of a received markdown document as plain text.\")\n- `text/html` is RECOMMENDED (to do complex things not possible with markdown)\n\nIn other words, markdown parsing support is optional, as is any more complex part of it.\n\nThe purpose of gfm-mimi - as I understand - is to make the gfm well-defined and fully interoperable (whenever things are optional in gfm, they are technically not interoperable). The idea is not to create new extensions on top of gfm or to design a new markup language.\n\nIf you create a new markup language that provides MIMI-specific features not available in any other markup language, you open an infinite can of worms of having to maintain complex media formats for eternity, keeping it up to date with latest developments. It's not unlikely that media - including text document - is going to change drastically in the next 20 years with VR/AR/3D material.\n\nI thus strongly advice to not come up with any custom media type (gfm-mimi is already a stretch in this regard, but sensible given gfm is not well-defined). The charter also says we \"will seek to reuse existing primitives (especially existing semantics) including previously defined message headers, MIME types, and URIs where practical\".\n\nSo I guess our main disagreements are:\n- I consider markdown optional, everything that looks terrible when rendered as plain text should also have a `text/plain` alternative for recipients that don't do markdown. \n- I consider sharing files and displaying them inline an important feature that needs to work *independent* of markdown.\n- I think using internal references from markdown/html/* is good in that it extends what can be done. The reference by URI system is very generic and would work for a variety of media formats already existing and likely for future formats.\n- Having more options also means being more extensible. It may be useless that you can do the same thing in two different ways today, but there might be valid usecases for it in the future.\n\nAs a person involved with XMPP, I'm a huge fan of building systems that are forwards and backwards compatible. XMPP clients and servers from 20 years ago can interact perfectly fine with those from today - except of course for the subset of features not available back then. Being able to fallback to plain text for almost everything (e.g. sending a file to a client not supporting it will show an http URL to the file instead) is one way to ensure this.",
          "createdAt": "2025-04-01T18:47:16Z",
          "updatedAt": "2025-04-01T18:47:16Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOJiBc4M6ur7g5",
      "title": "Provide example how to extended MIMI content",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/53",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-19T07:33:06Z",
      "updatedAt": "2025-03-19T07:33:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 54,
      "id": "I_kwDOJiBc4M6yveo1",
      "title": "Example message IDs are calculated incorrectly",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/54",
      "state": "CLOSED",
      "author": "bitbltr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The wrong URI is used to generate the hash_output.\n\nIn generate-examples.py, line 91 is\n```\nroom_uri = message_array[5][SENDER]\n```\n\nShould be:\n```\nroom_uri = message_array[5][ROOM]\n```\n",
      "createdAt": "2025-04-16T07:51:54Z",
      "updatedAt": "2025-04-17T18:30:25Z",
      "closedAt": "2025-04-17T18:30:24Z",
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Need to actually generate the examples to correct the original issue.",
          "createdAt": "2025-04-17T17:34:46Z",
          "updatedAt": "2025-04-17T17:34:46Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I did generate the example files on my machine. I just didn't know if I should include them in the PR or if you had a process for that so the proposal would get updated. Happy to update the examples directory",
          "createdAt": "2025-04-17T17:40:55Z",
          "updatedAt": "2025-04-17T17:40:55Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "With the combination of #56 and #57 this can be closed now.",
          "createdAt": "2025-04-17T18:30:24Z",
          "updatedAt": "2025-04-17T18:30:24Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOJiBc4M6zEmsL",
      "title": "Salt length is inconsistent",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/issues/58",
      "state": "OPEN",
      "author": "bitbltr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The message format schema in sections 4.1. and A.1. defines the salt as a 16-octet value\n```\nsalt: bstr .size 16\n```\n\nThe example messages use 16-octets, but section 3.3. defines the salt as 32-octets:\n```\nEvery MIMI content message contains a 32-octet per-message cryptographically random salt\n```\n\nI believe section 3.3 should define the salt as a 16-octet value, and section 9.2. (\"Generating the random salt\") should be changed to specify the use of the first 16-octets of the hash output:\n```\nhash_output = HMAC_SHA256( salt_base_secret, nonce )\nsalt = hash_output[0..15]\n```",
      "createdAt": "2025-04-18T08:01:13Z",
      "updatedAt": "2025-04-18T08:01:13Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "PR_kwDOJiBc4M5UK8vS",
      "title": "Fix references and update BCP14 boilerplate",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/2",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Updated BCP14 boilerplate\r\n- Use correct RFC number for BCP14 and for Language-tags definition\r\n- Move CPIM to informative reference\r\n- Move HTML to normative reference",
      "createdAt": "2023-06-28T18:34:46Z",
      "updatedAt": "2023-06-28T18:35:04Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "df32f84c10b01abc82515041e94f6b2cb6d31230",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "rohan/fixrefs1",
      "headRefOid": "476639e8b25e1799b9e5afb5dfdf0767604eaf13",
      "closedAt": "2023-06-28T18:34:59Z",
      "mergedAt": "2023-06-28T18:34:59Z",
      "mergedBy": "rohan-wire",
      "mergeCommit": {
        "oid": "547f55db1b5edff1567fca91d4dac79d4c91a98c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDOJiBc4M5Ujpif",
      "title": "Create README.md",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/3",
      "state": "CLOSED",
      "author": "soroshsabz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "WG reviewed"
      ],
      "body": "ITNOA\r\n\r\nI create a simple README.md for this project",
      "createdAt": "2023-07-03T20:17:35Z",
      "updatedAt": "2024-05-08T17:47:28Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "547f55db1b5edff1567fca91d4dac79d4c91a98c",
      "headRepository": "soroshsabz/draft-ietf-mimi-content",
      "headRefName": "main",
      "headRefOid": "c0c29184d446bbfc64579b7cce7e09a2cc88389a",
      "closedAt": "2024-05-08T17:47:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "soroshsabz",
          "authorAssociation": "NONE",
          "body": "@rohan-wire please review it\r\n\r\nthanks",
          "createdAt": "2023-07-03T20:17:53Z",
          "updatedAt": "2023-07-03T20:17:53Z"
        },
        {
          "author": "soroshsabz",
          "authorAssociation": "NONE",
          "body": "cc @coopdanger",
          "createdAt": "2023-07-04T10:31:36Z",
          "updatedAt": "2023-07-04T10:31:36Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, while a README would be nice, I don't want to maintain text from the Abstract/Intro in two different places. I will add a README if I migrate over from mmark to kramdown",
          "createdAt": "2024-05-08T17:47:27Z",
          "updatedAt": "2024-05-08T17:47:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOJiBc4M5qLFlR",
      "title": "Use std::optional where appropriate",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/9",
      "state": "CLOSED",
      "author": "alvestrand",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Fixes #8\r\nThis is a first pass, showing the resulting simplification.\r\nNot all opportunities for optional have been taken care of.\r\n",
      "createdAt": "2024-03-20T04:04:03Z",
      "updatedAt": "2024-04-23T21:56:21Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "94b370da8a2fd9334ba0f00970eb46d6833db019",
      "headRepository": "alvestrand/draft-ietf-mimi-content",
      "headRefName": "optional",
      "headRefOid": "c90127dba99a5c8d184a46b59daaa9357dcf6934",
      "closedAt": "2024-04-23T21:56:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced all the abstract C++ syntax with TLS PL and CBOR. Closing. ",
          "createdAt": "2024-04-23T21:56:21Z",
          "updatedAt": "2024-04-23T21:56:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 16,
      "id": "PR_kwDOJiBc4M5xjMlC",
      "title": "Use CBOR",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/16",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update draft to use CBOR for the binary format, \r\n\r\n- except for Appendix B (TODO)",
      "createdAt": "2024-06-05T12:47:52Z",
      "updatedAt": "2024-12-04T16:55:41Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "0a440f03b107552b4f94314758761821fefb9d3b",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "cbor-format",
      "headRefOid": "dd29b9402c0b788482a3a3edc8165aafcde50aff",
      "closedAt": "2024-06-05T17:26:32Z",
      "mergedAt": "2024-06-05T17:26:32Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "acfeeac506aff9f80409b003043243d6b76fcc2c"
      },
      "comments": [
        {
          "author": "hellp",
          "authorAssociation": "NONE",
          "body": "@rohanmahy I saw IETF's announcement of RFC 9582 the other day, and noticed that they use *CBOR sequences* to encode their messages instead of CBOR arrays (https://www.rfc-editor.org/rfc/rfc9528.html#name-edhoc-message-1).\r\n\r\nI wonder if that's worth a consideration for mimi-content as well?\r\n\r\n- Pro: It's a (tiny bit) closer to the structs that were used in the TLS-PL examples.\r\n- Pro: It saves the initial byte, the wrapping \"array of length x\".\r\n- Con: Decoder/parser support may be worse; at least Python's cbor2 currently does not support CBOR sequences in its API (interestingly enough it seems to support it in the CLI helper).\r\n",
          "createdAt": "2024-06-06T23:34:04Z",
          "updatedAt": "2024-06-06T23:34:04Z"
        },
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Fabian,\r\nThat's a great question. While I used CBOR sequences for some logical\r\ninternal groupings in the CDDL to make it more readable, I avoided using\r\nthem for the NestedPart and top level definitions. The other main\r\ndisadvantage is that you can't convert the CBOR sequences into JSON for\r\nlogging or debugging purposes, and for the NestedPart you don't have a\r\nfixed length sequence, since the number of elements depends if it is a\r\nnull, single, external, or multiple.\r\n\r\nAnother option is to turn sequences into an embedded CBOR bstr by enclosing\r\neach in << and >>. This also makes logging/debugging more difficult.\r\n\r\nLet's see if the CBOR community and potential implementers have anything to\r\nsay about these tradeoffs.\r\n\r\nthanks,\r\n-rohan\r\n\r\n\r\nOn Fri, Jun 7, 2024, 01:34 Fabian Neumann ***@***.***> wrote:\r\n\r\n> @rohanmahy <https://github.com/rohanmahy> I saw IETF's announcement of\r\n> RFC 9582 the other day, and noticed that they use *CBOR sequences* to\r\n> encode their messages instead of CBOR arrays (\r\n> https://www.rfc-editor.org/rfc/rfc9528.html#name-edhoc-message-1).\r\n>\r\n> I wonder if that's worth a consideration for mimi-content as well?\r\n>\r\n>    - Pro: It's a (tiny bit) closer to the structs that were used in the\r\n>    TLS-PL examples.\r\n>    - Pro: It saves the initial byte, the wrapping \"array of length x\".\r\n>    - Con: Decoder/parser support may be worse; at least Python's cbor2\r\n>    currently does not support CBOR sequences in its API (interestingly enough\r\n>    it seems to support it in the CLI helper).\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/16#issuecomment-2153564583>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AADSQPS2H2ZYAKSBVXQWDXTZGDWYDAVCNFSM6AAAAABI2UXGBGVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCNJTGU3DINJYGM>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2024-06-07T05:38:30Z",
          "updatedAt": "2024-06-07T05:38:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOJiBc4M5x5Yia",
      "title": "Multipart examples",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/17",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Make CBOR multipart examples. Closes #11 ",
      "createdAt": "2024-06-09T16:41:44Z",
      "updatedAt": "2024-12-04T16:55:35Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "85a6244c9b23568e5abb2147741e1c0133836b63",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "multipart-examples",
      "headRefOid": "5dee751ed3a86d7a3489bcfc032cb2daf9b47dfc",
      "closedAt": "2024-06-09T16:42:19Z",
      "mergedAt": "2024-06-09T16:42:19Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "dd05ecb66988110f8a9218adeec0f7efee825035"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 21,
      "id": "PR_kwDOJiBc4M59-26-",
      "title": "Add filename to ExternalPart",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/21",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "when sending explicitly uploaded content, it is useful to have a recommended filename.\r\n\r\naddresses issue #20 ",
      "createdAt": "2024-10-08T17:55:57Z",
      "updatedAt": "2024-12-04T16:55:33Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "20ee4e3760f1759a58c25d0bca98d2dbb041569e",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "filename",
      "headRefOid": "b17c83d316367682307e4e138c17d02af59b0e3f",
      "closedAt": "2024-10-20T21:54:22Z",
      "mergedAt": "2024-10-20T21:54:22Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "9b8a6a32a9d0a05169742478de1a92759338372c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6MYgeP",
          "commit": {
            "abbreviatedOid": "b17c83d"
          },
          "author": "turt2live",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I haven't reviewed exact syntax, but I support the idea",
          "createdAt": "2024-10-08T18:29:14Z",
          "updatedAt": "2024-10-08T18:29:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOJiBc4M6EnI_P",
      "title": "Address issues #12, #22, #23, #24, #25, #30, #31, #33",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/35",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address the following non-controversial issues:\r\n- remove tags from URIs in ExternalPart (#12 )\r\n- support relative expiration times (#22 )\r\n- add specificity to Markdown rules (#23 )\r\n- #24 \r\n- #25 \r\n- remove URL tags in implied headers\r\n- #31 \r\n- #30 \r\n- #33  ",
      "createdAt": "2024-12-09T22:08:52Z",
      "updatedAt": "2024-12-20T22:11:57Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "9b8a6a32a9d0a05169742478de1a92759338372c",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "small-issues",
      "headRefOid": "b73e609c4f10b2f12f574fff590edd10e7eb7afb",
      "closedAt": "2024-12-18T19:23:22Z",
      "mergedAt": "2024-12-18T19:23:22Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "11bd9b7db51ae2076d404c217ca65cc1bce37d3b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6VN8N3",
          "commit": {
            "abbreviatedOid": "08fe355"
          },
          "author": "br-hale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-14T01:46:45Z",
          "updatedAt": "2024-12-14T01:46:46Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "General question: should this (and the following) \"SHOULD\" be a \"MUST\"? It seems odd to me at this level that there would be an (application set) policy that has a valid reason to be ignored. Surely if there is a valid reason to not follow an existing authorization policy, the policy itself should be updated, vs the override occurring here.",
              "createdAt": "2024-12-14T01:46:45Z",
              "updatedAt": "2024-12-14T01:46:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VOFci",
          "commit": {
            "abbreviatedOid": "08fe355"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-14T03:09:36Z",
          "updatedAt": "2024-12-14T03:09:36Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "A messaging app where everyone is encouraged to edit each other's messages (like a collaborative work space) might not need an explicit policy, but in the MIMI case, you are probably right.",
              "createdAt": "2024-12-14T03:09:36Z",
              "updatedAt": "2024-12-14T03:09:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VPD2w",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-14T08:47:33Z",
          "updatedAt": "2024-12-14T08:52:24Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Why do we want to support hiding content using HTML comments in messaging?\n\nThis will be rendered entirely different in clients that just display the markdown as plain text (which is allowed as written above), so using comments could be used as a weird way to display different content to different clients.\n\nI'm of course aware that the multipart/alternative semantics also allow for this, but that is intentional and clearly specified, this one seems less intentional and is easier to miss.\n\nSome context: In XMPP there is language based alternative selection of the message body. It's a rarely used festure, but some clients will display an indication and even allow selection of the language when they receive a multi-language message. This makes it possible to spot messages that have different content in their different alternatives, which is important for example in the context of moderation.",
              "createdAt": "2024-12-14T08:47:33Z",
              "updatedAt": "2024-12-14T08:52:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VPnlq",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-14T15:03:56Z",
          "updatedAt": "2024-12-14T15:03:56Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "If you look at the GFM spec, it is the only way to separate two otherwise valid types of markup. If you search in the GFM spec for the comment string with a single space, you will find it.\r\nIt is unfortunate, if the comment is displayed raw, but it would not be sent frequently, and it would be an annoyance, but should not interfere with the human understanding the rest of the content.",
              "createdAt": "2024-12-14T15:03:56Z",
              "updatedAt": "2024-12-14T15:03:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VPtXd",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-14T16:59:41Z",
          "updatedAt": "2024-12-14T16:59:41Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Is this a common variant of GFM? Are there parsers/processors available that support this variant? Or are we just about to create a new variant of Markdown incompatible with everything that's already out there?\r\n\r\n\r\nThe two examples in the GFM spec could both also be realized without the `<!-- -->`.\r\n\r\n<details><summary>Example 288</summary>\r\n\r\n```markdown\r\n- foo\r\n- bar\r\n\r\n* baz\r\n* bim\r\n```\r\n\r\n- foo\r\n- bar\r\n\r\n* baz\r\n* bim\r\n\r\n</details> \r\n\r\n<details><summary>Example 289</summary>\r\n\r\n~~~markdown\r\n-   foo\r\n\r\n    notcode\r\n\r\n-   foo\r\n```\r\ncode\r\n```\r\n~~~\r\n\r\n-   foo\r\n\r\n    notcode\r\n\r\n-   foo\r\n```\r\ncode\r\n```\r\n\r\n</details> \r\n\r\nI would even go as far as saying that the variant without empty HTML comment is more readable  when printed in plain than the variant with empty HTML comment.\r\n\r\nI'm not saying there aren't going to be things that can't be done in GFM without using those empty HTML comments - but I'm also certain that there are things that can't be done in GFM even with those, so we seem to have settled on accepting these weird restrictions that come from using a Markdown language. ",
              "createdAt": "2024-12-14T16:59:41Z",
              "updatedAt": "2024-12-14T16:59:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VTjVj",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T01:27:00Z",
          "updatedAt": "2024-12-16T01:27:00Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "I had mixed results with your suggestions..\r\n\r\n(This is **not** a **variant** of GFM, it is **the spec** for GFM, which of course is implemented by GitHub.)\r\n\r\nFor Example 289, using triple-tilde worked to interrupt a list with a code block:\r\n\r\n1) a\r\n2) b\r\n\r\n```\r\ncode\r\n```\r\n\r\n1) 1 (new list)\r\n2) 2\r\n\r\nBut for Example 288, using different punctuation characters for an unordered list did not create a new list for me, and that does not cover the case of multiple ordered lists (I used an HTML comment here as a separator, but `<div/>` would havealso  worked too):\r\n\r\n1) a\r\n2) b\r\n\r\n<!-- -->\r\n\r\n1) x\r\n2) y",
              "createdAt": "2024-12-16T01:27:00Z",
              "updatedAt": "2024-12-16T01:27:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VVaAT",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "mar-v-in",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-16T08:05:04Z",
          "updatedAt": "2024-12-16T08:05:04Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "With \"variant\" I was referring to the variant of GFM you're proposing in this document: GFM, with the three GFM extensions listed, but disallowing raw HTML except the empty HTML comment by displaying the HTML as verbatim code (by replacing `<` with `&lt;`). GFM clearly allows raw HTML and there is an extension to filter some tags to make it safe, but filtering all tags and non-empty HTML comments is behavior noncompliant with the GFM spec. As such using the `text/markdown;variant=GFM` content type for this is inappropriate. I also question if there's any markdown implementation out there that allows to be configured exactly as per this specification, and if the answer is no, I would say that specifying our own variant here is probably a bad idea, because it will inevitably result in people using markdown processors that divert from the specification.\r\n\r\nUsing different punctuation for list items clearly creates a new list in GFM, but I'm pretty sure there are other markdown variants where it doesn't. See [section 5.4](https://github.github.com/gfm/#lists) of GFM spec:\r\n> A [list](https://github.github.com/gfm/#list) is a sequence of one or more list items [of the same type](https://github.github.com/gfm/#of-the-same-type). The list items may be separated by any number of blank lines.\r\n>\r\n> Two list items are [of the same type](https://github.github.com/gfm/#of-the-same-type) if they begin with a [list marker](https://github.github.com/gfm/#list-marker) of the same type. Two list markers are of the same type if (a) they are bullet list markers using the same character (-, +, or *) or (b) they are ordered list numbers with the same delimiter (either . or )).\r\n\r\nIt also explains that, as there are two valid delimiters for ordered lists, it does work for them as well.\r\n\r\n<details><summary>Example 288 for ordered lists</summary>\r\n<p>\r\n\r\n```\r\n1. a\r\n2. b\r\n\r\n1) x\r\n2) y\r\n```\r\n\r\n1. a\r\n2. b\r\n\r\n1) x\r\n2) y\r\n\r\n</p>\r\n</details> ",
              "createdAt": "2024-12-16T08:05:04Z",
              "updatedAt": "2024-12-16T08:05:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VrvdF",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T09:26:29Z",
          "updatedAt": "2024-12-18T10:16:36Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Maybe it would be more future-proof to make this an enum: None // Relative // Absolute, similar to the SinglePart // MultiPart // ExternalPart enum.",
              "createdAt": "2024-12-18T09:26:29Z",
              "updatedAt": "2024-12-18T10:16:36Z"
            },
            {
              "originalPosition": 284,
              "body": "Typo in \"acceptable\", I can recommend installing something like https://ltex-plus.github.io/ltex-plus/index.html",
              "createdAt": "2024-12-18T09:38:38Z",
              "updatedAt": "2024-12-18T10:16:36Z"
            },
            {
              "originalPosition": 410,
              "body": "typo \"other a\"",
              "createdAt": "2024-12-18T09:46:55Z",
              "updatedAt": "2024-12-18T10:16:36Z"
            },
            {
              "originalPosition": 6,
              "body": "Timestamps still have the 62 tag, where does this number come from?",
              "createdAt": "2024-12-18T10:02:49Z",
              "updatedAt": "2024-12-18T10:16:36Z"
            },
            {
              "originalPosition": 393,
              "body": "I think the list below still needs to be updated:\r\n\r\n  > - a topic is specified, but an `inReplyTo` or `replaces` field refers to a\r\n    message outside of the topic\r\n    \r\nThis can be removed?\r\n    \r\n> * expires\r\n>   - refers to a date more than a year in the past\r\n>   - refers to a date more than a year in the future\r\n\r\nShould this differentiate between relative and absolute timestamps?",
              "createdAt": "2024-12-18T10:13:28Z",
              "updatedAt": "2024-12-18T10:16:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VvxgT",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T16:30:41Z",
          "updatedAt": "2024-12-18T16:30:42Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "How would you feel about defining `text/markdown;variant=GFM-noHTML` (no HTML comment or other PIs either)?\r\n\r\nI could register this variant in the variant registry. ",
              "createdAt": "2024-12-18T16:30:41Z",
              "updatedAt": "2024-12-18T16:30:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VvyKK",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T16:31:52Z",
          "updatedAt": "2024-12-18T16:31:52Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "do you have an existence proof of an example third part that would take uint32 time?",
              "createdAt": "2024-12-18T16:31:52Z",
              "updatedAt": "2024-12-18T16:31:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6Vvzox",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T16:34:08Z",
          "updatedAt": "2024-12-18T16:34:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It is a CBOR tag for timestamps. I can remove this or expand the explanation. This really should depend on discussing the timestamp granularity in mimi-protocol first.",
              "createdAt": "2024-12-18T16:34:08Z",
              "updatedAt": "2024-12-18T16:34:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6Vv1dF",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T16:37:14Z",
          "updatedAt": "2024-12-18T16:37:15Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "> I think the list below still needs to be updated:\r\n> \r\n> > * a topic is specified, but an `inReplyTo` or `replaces` field refers to a\r\n> >   message outside of the topic\r\n> \r\n> This can be removed?\r\n\r\nyes\r\n\r\n> > * expires\r\n> >   \r\n> >   * refers to a date more than a year in the past\r\n> >   * refers to a date more than a year in the future\r\n> \r\n> Should this differentiate between relative and absolute timestamps?\r\n\r\nI can add an extra sentence or two. More than a year in the future is possible with both absolute and relative timestamps. More than a year in the past is only possible with absolute timestamps.\r\n",
              "createdAt": "2024-12-18T16:37:14Z",
              "updatedAt": "2024-12-18T16:37:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VwCUZ",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T17:00:08Z",
          "updatedAt": "2024-12-18T17:00:09Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "An option we could add in the future would be \"delete this message when the other user explicitly marked this message as read\" or \"when the other user has replied to this message\"",
              "createdAt": "2024-12-18T17:00:08Z",
              "updatedAt": "2024-12-18T17:00:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VwwEi",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T18:37:22Z",
          "updatedAt": "2024-12-18T18:37:23Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Resolved in interim today. Created Issue #39 to track as future extensibility point. Will merge as-is",
              "createdAt": "2024-12-18T18:37:22Z",
              "updatedAt": "2024-12-18T18:37:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6Vwx_z",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T18:40:08Z",
          "updatedAt": "2024-12-18T18:40:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Tracked in issue #13",
              "createdAt": "2024-12-18T18:40:08Z",
              "updatedAt": "2024-12-18T18:40:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VwyaT",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T18:40:36Z",
          "updatedAt": "2024-12-18T18:40:37Z",
          "comments": [
            {
              "originalPosition": 278,
              "body": "I did not know that GFM is a strict superset of Commonmark. GFM = CommonMark + tables + task lists + strikethrough + more autolinks + less raw html. Extensions are not optional, so actually my comment about deciding on extensions did not make sense.",
              "createdAt": "2024-12-18T18:40:37Z",
              "updatedAt": "2024-12-18T18:40:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6Vw1e7",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T18:45:43Z",
          "updatedAt": "2024-12-18T18:45:43Z",
          "comments": [
            {
              "originalPosition": 393,
              "body": "Fixed.",
              "createdAt": "2024-12-18T18:45:43Z",
              "updatedAt": "2024-12-18T18:45:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6VxI8V",
          "commit": {
            "abbreviatedOid": "b9b098e"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-18T19:22:56Z",
          "updatedAt": "2024-12-18T19:22:56Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "At MIMI interim agreed we will go forward with a new variant GFM-MIMI that has no HTML.",
              "createdAt": "2024-12-18T19:22:56Z",
              "updatedAt": "2024-12-18T19:22:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOJiBc4M6FNDgP",
      "title": "Change Message ID construction",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/36",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the first of two PRs to change the message ID construction to use a per-message client-generated salt in the mesage and the hash of the MIMI content with the sender URI and room URI, as described in issue #34 . This also has the side effect of fixing issue #29 for free.\r\n\r\nThe second PR will change the examples to use the new construction. This is a larger change because text needs to be fixed in several places in the text, not just generated from the EDN files for each example.",
      "createdAt": "2024-12-14T02:42:05Z",
      "updatedAt": "2025-02-28T22:10:01Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "11bd9b7db51ae2076d404c217ca65cc1bce37d3b",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "message-id",
      "headRefOid": "47adf86e9b456a8995de6861f44bd068f5de1557",
      "closedAt": "2024-12-18T19:30:30Z",
      "mergedAt": "2024-12-18T19:30:30Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "1efb6c8ef5371b8261ceeca14f6f6be3d3393db4"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "During interim, agreed we would merge this so that the Editor's Copy would refer to the version with this change when requesting a review of the franking mechanism from CFRG.",
          "createdAt": "2024-12-18T19:30:26Z",
          "updatedAt": "2024-12-18T19:30:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 37,
      "id": "PR_kwDOJiBc4M6FNFrb",
      "title": "Remove lastSeen",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/37",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed at the last interim and in issue #27 , remove the lastSeen mechanism now that hub accepted timestamp is mandatory. The client's detecting that a malicious hub would be better served by using a mechanism like AppAck or the MIMI message delivery reporting system. ",
      "createdAt": "2024-12-14T03:06:23Z",
      "updatedAt": "2025-02-28T22:09:47Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "d9579746fcd6fb8825919fffcc37c2b6cc686307",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "last-unseen",
      "headRefOid": "51ec79f0afa75d472f71a58983cfcae806b63bb6",
      "closedAt": "2025-01-07T18:03:42Z",
      "mergedAt": "2025-01-07T18:03:42Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "f1306131bd5755bae9c262e9a594325cfaca0214"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6XF91w",
          "commit": {
            "abbreviatedOid": "b2358f8"
          },
          "author": "kkohbrok",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-07T16:55:45Z",
          "updatedAt": "2025-01-07T16:55:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "PR_kwDOJiBc4M6G8q0q",
      "title": "fix: use new expiration struct",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/40",
      "state": "MERGED",
      "author": "timokoesters",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This makes it match up with the definition in mimi-content.cddl",
      "createdAt": "2025-01-07T14:43:26Z",
      "updatedAt": "2025-01-07T16:40:29Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "de9cbfffe247f9ff6f0f0e4ec7328d012d05e7cb",
      "headRepository": "timokoesters/draft-ietf-mimi-content",
      "headRefName": "expiration",
      "headRefOid": "6b53728048168a49025d2e2285af5cceb9860174",
      "closedAt": "2025-01-07T16:40:28Z",
      "mergedAt": "2025-01-07T16:40:28Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "d9579746fcd6fb8825919fffcc37c2b6cc686307"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @timokoesters ",
          "createdAt": "2025-01-07T16:40:26Z",
          "updatedAt": "2025-01-07T16:40:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 41,
      "id": "PR_kwDOJiBc4M6HCd69",
      "title": "fix: some typos in mimi-content.md",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/41",
      "state": "MERGED",
      "author": "timokoesters",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-08T08:45:49Z",
      "updatedAt": "2025-01-08T13:10:19Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "f1306131bd5755bae9c262e9a594325cfaca0214",
      "headRepository": "timokoesters/draft-ietf-mimi-content",
      "headRefName": "typos",
      "headRefOid": "cb4ee478c662b1ce0c0145503ec67701ac91964d",
      "closedAt": "2025-01-08T13:10:19Z",
      "mergedAt": "2025-01-08T13:10:19Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "c452b1a4575f6a7a3f5707d05248139e2321412f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6XOSVG",
          "commit": {
            "abbreviatedOid": "ac81f26"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-08T13:09:28Z",
          "updatedAt": "2025-01-08T13:09:28Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "```suggestion\r\nin an ExternalPart with a disposition of `session`, which could be processed\r\n```",
              "createdAt": "2025-01-08T13:09:28Z",
              "updatedAt": "2025-01-08T13:09:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6XOSrn",
          "commit": {
            "abbreviatedOid": "cb4ee47"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-01-08T13:10:08Z",
          "updatedAt": "2025-01-08T13:10:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "PR_kwDOJiBc4M6MLy-M",
      "title": "Build the CBOR examples using a script",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/46",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- [x] Build the CBOR examples using a script. \r\n- [x] Compare the EDN in the examples to the generated CBOR\r\n- [x] Regenerate pretty printed CBOR manually\r\n- [x] fix remaining inconsistencies with the examples",
      "createdAt": "2025-02-23T05:42:16Z",
      "updatedAt": "2025-02-28T22:09:50Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "c452b1a4575f6a7a3f5707d05248139e2321412f",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "script-examples",
      "headRefOid": "0aeb570b16e147ba0a909ec59441e42152173885",
      "closedAt": "2025-02-26T18:57:20Z",
      "mergedAt": "2025-02-26T18:57:20Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "a1d701a6cf67a1ea4716f4bf13b5ad4512aa2296"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Also addresses #45  and #13 ",
          "createdAt": "2025-02-24T02:23:04Z",
          "updatedAt": "2025-02-24T02:23:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6dqxrc",
          "commit": {
            "abbreviatedOid": "342c129"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for updating the examples, I will see if my implementation still passes these tests \ud83d\udc4d ",
          "createdAt": "2025-02-26T17:11:41Z",
          "updatedAt": "2025-02-26T17:13:32Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Nit: dispos(i)tion still has a typo",
              "createdAt": "2025-02-26T17:11:41Z",
              "updatedAt": "2025-02-26T17:13:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6drW2F",
          "commit": {
            "abbreviatedOid": "342c129"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T18:03:33Z",
          "updatedAt": "2025-02-26T18:03:34Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n    6,                                   # disposition = attachment\r\n```",
              "createdAt": "2025-02-26T18:03:33Z",
              "updatedAt": "2025-02-26T18:03:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6dr2vi",
          "commit": {
            "abbreviatedOid": "342c129"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T18:45:24Z",
          "updatedAt": "2025-02-26T18:45:24Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "There are ~10 more occurrences of this typo :)",
              "createdAt": "2025-02-26T18:45:24Z",
              "updatedAt": "2025-02-26T18:45:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6dr8pZ",
          "commit": {
            "abbreviatedOid": "342c129"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T18:55:18Z",
          "updatedAt": "2025-02-26T18:55:18Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "fixed in 0aeb570b16e147ba0a909ec59441e42152173885",
              "createdAt": "2025-02-26T18:55:18Z",
              "updatedAt": "2025-02-26T18:55:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 48,
      "id": "PR_kwDOJiBc4M6MrMs6",
      "title": "warn clients not to double render CID referenced parts",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/48",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Give guidance to clients about processing MultiPart (including nested MultiPart) content.\r\n- ignore the parts that are not chosen from chooseOne\r\n- make sure that parts referenced by content ID (CID) URIs aren't rendered twice.\r\n\r\naddresses #30 \r\n\r\n@timokoesters ",
      "createdAt": "2025-02-26T16:38:48Z",
      "updatedAt": "2025-02-28T22:09:55Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "c452b1a4575f6a7a3f5707d05248139e2321412f",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "inline",
      "headRefOid": "3e70f9c244f1e29014152002e7c764b1b761f036",
      "closedAt": "2025-02-28T22:09:05Z",
      "mergedAt": "2025-02-28T22:09:05Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "ff19bcc2d8f3f1954b801150cd48e675d0d6c80b"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to go ahead and merge this to get a new draft version submitted. I am happy to improve the wording later @timokoesters.",
          "createdAt": "2025-02-28T22:08:13Z",
          "updatedAt": "2025-02-28T22:08:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6drWLi",
          "commit": {
            "abbreviatedOid": "bbb096f"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T18:02:46Z",
          "updatedAt": "2025-02-26T18:02:47Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nParts. The remaining Parts might still reference each other in content ID URI. To prevent rendering a Part more than once, the client can handle the remaining Parts in order, skipping a Part if it was already referred to by a previously handled Part. If a MultiPart is skipped, all inner Parts are skipped too. All dispositions are handled the same: If a Part of disposition \"reaction\" is skipped, the reaction will not be counted. If a Part of disposition \"attachment\" is skipped, it will not be be visible in the attachment list.\r\n```\r\n\r\nI tried to make the wording more clear and generalized it to all dispositions. How does this sound to you?",
              "createdAt": "2025-02-26T18:02:46Z",
              "updatedAt": "2025-02-26T18:02:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6drl_8",
          "commit": {
            "abbreviatedOid": "bbb096f"
          },
          "author": "timokoesters",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T18:22:18Z",
          "updatedAt": "2025-02-26T18:22:18Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I realized there are more edge cases. Can the initial chooseOne resolution consider what Parts reference? What happens, if a Part references a chooseOne MultiPart? That logic could become complex and expensive. What if a Part references itself, or its parent? Or two Parts reference each other recursively?",
              "createdAt": "2025-02-26T18:22:18Z",
              "updatedAt": "2025-02-26T18:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6drvzY",
          "commit": {
            "abbreviatedOid": "bbb096f"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-26T18:37:37Z",
          "updatedAt": "2025-02-26T18:37:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "this style of cid: should only ever reference an individual part (SinglePart or ExternalPart). let me update with some text to that effect",
              "createdAt": "2025-02-26T18:37:37Z",
              "updatedAt": "2025-02-26T18:37:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6du6tO",
          "commit": {
            "abbreviatedOid": "bbb096f"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-27T01:29:43Z",
          "updatedAt": "2025-02-27T01:29:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "it's not clear if skipped in this context is filtering out unselected branches of a chooseOne (I use discarded above), or they are being skipped because they were already processed via content ID.\r\n\r\nIf the later, we should make it explicit that CID needs to refer to an individual part, so you could not \"skip\" a MultiPart.",
              "createdAt": "2025-02-27T01:29:43Z",
              "updatedAt": "2025-02-27T01:29:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6d7gyk",
          "commit": {
            "abbreviatedOid": "bbb096f"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T03:26:17Z",
          "updatedAt": "2025-02-28T03:26:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "@timokoesters what did you mean by skipping above, please?",
              "createdAt": "2025-02-28T03:26:17Z",
              "updatedAt": "2025-02-28T03:26:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJiBc4M6d7iGX",
          "commit": {
            "abbreviatedOid": "bbb096f"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-28T03:31:19Z",
          "updatedAt": "2025-02-28T03:31:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThis format of the content ID URI in MIMI MUST only reference the `partIndex` of a SinglePart or ExternalPart.\r\n```",
              "createdAt": "2025-02-28T03:31:19Z",
              "updatedAt": "2025-02-28T03:33:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "PR_kwDOJiBc4M6MvR6F",
      "title": "IANA Register MIMI extensions used in draft",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/50",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-27T04:29:10Z",
      "updatedAt": "2025-02-28T22:09:52Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "a1d701a6cf67a1ea4716f4bf13b5ad4512aa2296",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "reg-extensions",
      "headRefOid": "1e26cca22cddbf1c6c9ef8bd064262f0f5406bfe",
      "closedAt": "2025-02-28T21:36:47Z",
      "mergedAt": "2025-02-28T21:36:47Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "250f2db8a7fe60d9292b562b7bdd36151ebdb97c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6eD0pK",
          "commit": {
            "abbreviatedOid": "1e26cca"
          },
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T21:27:01Z",
          "updatedAt": "2025-02-28T21:27:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOJiBc4M6MvcpZ",
      "title": "Remove deliver report timestamp and fix report example",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/51",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also:\r\n- add more description of the semantics of each delivery status value \r\n- regenerated old files (pretty printed CBOR)\r\n- reformat long lines in draft, CDDL, and EDN examples",
      "createdAt": "2025-02-27T05:05:54Z",
      "updatedAt": "2025-02-28T22:09:53Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "a1d701a6cf67a1ea4716f4bf13b5ad4512aa2296",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "reports",
      "headRefOid": "d6c23a7d604d40bd475b24b55bbd27a5a466d1bc",
      "closedAt": "2025-02-28T21:36:32Z",
      "mergedAt": "2025-02-28T21:36:32Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "880793bb66a1dd607f8e907b9ef24209cbe28c12"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6eD2Bw",
          "commit": {
            "abbreviatedOid": "d6c23a7"
          },
          "author": "bifurcation",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-02-28T21:30:55Z",
          "updatedAt": "2025-02-28T21:30:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOJiBc4M6M_lmR",
      "title": "Add Martin Thomson's draft template special sauce",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/52",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-02-28T22:28:50Z",
      "updatedAt": "2025-02-28T22:58:54Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "ff19bcc2d8f3f1954b801150cd48e675d0d6c80b",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "add-template",
      "headRefOid": "b1d32ece41754460bf2529cd8383cbaa52fcea65",
      "closedAt": "2025-02-28T22:33:37Z",
      "mergedAt": "2025-02-28T22:33:37Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "7b26fa1b9bd587c6c5fccd59b4040a4f941d1fdb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 55,
      "id": "PR_kwDOJiBc4M6Sy7OP",
      "title": "Use the correct numbered extension ID for ROOM",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/55",
      "state": "CLOSED",
      "author": "bitbltr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Fixes #54 ",
      "createdAt": "2025-04-16T07:57:39Z",
      "updatedAt": "2025-04-16T07:59:04Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "b262c9974dc659428094a14b9d4fd5eb8b3ac737",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "cdc37c8377034e74d1e12a31b9ddec544076b9bc",
      "closedAt": "2025-04-16T07:59:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOJiBc4M6Sy8zg",
      "title": "Use the correct numbered extension ID for ROOM",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/56",
      "state": "MERGED",
      "author": "bitbltr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #54 ",
      "createdAt": "2025-04-16T08:00:34Z",
      "updatedAt": "2025-04-17T17:32:58Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "b262c9974dc659428094a14b9d4fd5eb8b3ac737",
      "headRepository": "bitbltr/draft-ietf-mimi-content",
      "headRefName": "patch-1",
      "headRefOid": "d73c237a28f77107e090922da7e816c4e357038c",
      "closedAt": "2025-04-17T17:32:58Z",
      "mergedAt": "2025-04-17T17:32:58Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "603c4b19465dd1ed8c222c6d48046cd5e3bbc6e6"
      },
      "comments": [
        {
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch. Thanks!",
          "createdAt": "2025-04-17T17:31:55Z",
          "updatedAt": "2025-04-17T17:31:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJiBc4M6lfd3X",
          "commit": {
            "abbreviatedOid": "d73c237"
          },
          "author": "rohanmahy",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-17T17:30:54Z",
          "updatedAt": "2025-04-17T17:30:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOJiBc4M6TBusG",
      "title": "Regenerate all examples with corrected message IDs",
      "url": "https://github.com/ietf-wg-mimi/draft-ietf-mimi-content/pull/57",
      "state": "MERGED",
      "author": "rohanmahy",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After merge of #56 :\r\n- reran the program to generate the CBOR examples\r\n- fixed the (now different) message ID in all the EDN files and in the pretty printed examples\r\n- generated new version of implied-original.cbor and report.cbor from the EDN.\r\n- compared the EDN of all the other EDN files to the corresponding CBOR\r\n- ran validate all\r\n- made a note in the change log to this effect\r\n\r\nAddresses #54 \r\n",
      "createdAt": "2025-04-17T18:29:07Z",
      "updatedAt": "2025-04-17T18:29:48Z",
      "baseRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "baseRefName": "main",
      "baseRefOid": "603c4b19465dd1ed8c222c6d48046cd5e3bbc6e6",
      "headRepository": "ietf-wg-mimi/draft-ietf-mimi-content",
      "headRefName": "gen-examples",
      "headRefOid": "649b042a46447fd66844eae21cfc4cdc5e475137",
      "closedAt": "2025-04-17T18:29:48Z",
      "mergedAt": "2025-04-17T18:29:48Z",
      "mergedBy": "rohanmahy",
      "mergeCommit": {
        "oid": "d4eef97e3237d929913f13075c91c2c78ee2ad29"
      },
      "comments": [],
      "reviews": []
    }
  ]
}